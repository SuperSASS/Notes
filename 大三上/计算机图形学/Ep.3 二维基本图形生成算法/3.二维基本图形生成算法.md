# Ep.3 二位基本图形生成算法

把图形的数学公式（连续）描述成像素集（离散）。  
一个图形系统最基本要求能画一个点，因此跳过了点的光栅化。

## 一、直线的扫描转换

**基本概念：**

* 屏幕坐标：以笛卡尔坐标系（左下为原点），用扫描列号$x$和扫描行号$y$，来描述屏幕上像素的位置。
* 屏幕网格坐标：将像素作为占有大小的区域，交点既可以作为像素中点，也可以作为左下锚点。
* 图形扫描转换（光栅化）：将屏幕看作像素矩阵，每个像素有位置和颜色。用最佳**逼近于所显示图形**的**像素集合**，并用**指定属性**（如颜色）写像素的过程为光栅化。

**直线扫描转换的要求：**

* 所绘直线要直。
* 沿着线段分布的像素应均匀且连续，不能出现断裂。
* 生成速度快。

### 1. 直接生成法

直线扫描转换算法举例 - 直接生成法：

```c++
void DirectLine(int x0, int y0, int x1, int y1, int color)
{
    float k, b, y;
    /* 用斜率计算k, 再用点计算b */
    for (x = x0; x <= x1; x++)
        putpixel(x, (int)(k*x + b + 0.5)), color); // 注意像素位置用整数
}
```

在循环内每次都会计算一次浮点数乘法运算$kx+b$，复杂度高。

### 2. 数值微分法(DDA)

每次计算浮点数乘法运算$kx+b$较复杂，可以在此处优化，  
如“**数值微分法**”(**DDA**)，使用增量的方法。

其利用直线的微分方程$\frac{\mathrm{d}x}{\mathrm{d}y}=k$，生成直线时采用增量改变。  
如果$\Delta x$较大，采用$x$方向作为步进方向（**这样每次$y$变化小**直线才连续），  
$\Delta x=1$，$\Delta y = k\cdot\Delta x$，每次则用加法计算$x_{k+1}=x_k+\Delta x,y_{k+1}=y_k+\Delta y$。

通法为以下代码：

```c++
void Line_DDA(int x0, int y0, int x1, int y1, Color color)
{
    int delta_x, delta_y, steps, dx, dy; // delta_x为两端点横纵坐标距离，dx为增量
    // 计算delta_x, delta_y, 确定steps，并计算dx, dy
    delta_x = x1 - x0, delta_y = y1 - y0;
    steps = max(delta_x, delta_y);
    dx = delta_x / steps, dy = delta_y / steps;
    for (i = 1; i <= steps + 1; i++) // 注意：最后一个像素点需要额外putpixel一次
    {
        putpixel((int)(x + 0.5), (int)(y + 0.5), color); // 四舍五入生成像素点
        x += dx, y += dy;
    }
}
```

包含了斜率不存在的情况（此时`dx=0`）。

浮点数加法还是不及整数加法，继续优化。

### 3. 中点画线算法(Midpoint Line Drawing Algorithm)

通过在每列像素中，确定与理想直线最佳逼近的像素来进行扫描转换。

**算法描述：**

1. 给定直线段$L(P_0,P_1)$段两端点坐标$P_0(x_0,y_0)$、$P_1(x_1,y_1)$（⚠**必须保证$x_0<x_1$**，原因见下「注意 - 有关上述点与直线三种情况的补充」），  
   则直线方程为：
   $$
   F(x,y)=ax+by+c=0
   $$
   其中：$a=y_0-y_1$、$b=x_1-x_0$、$c=x_0y_1-x_1y_0$，且$b>0$  
   记直线斜率为$k$，先假定$0\le k\le 1$。
2. 则平面上任何点$(x,y)$与直线的相对位置有三种情况  
   ![三种位置情况](images/3.%E4%BA%8C%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95--09-22_08-13-36.png)  
   $$
   F(x_i, y_i)\left\{\begin{array}{ll}
   <0 & \textrm { 点 }(x_i, y_i) \textrm { 位于直线下方 } \\
   =0 & \textrm { 点 }(x_i, y_i) \textrm { 位于直线上 } \\
   >0 & \textrm { 点 }(x_i, y_i) \textrm { 位于直线上方 }
   \end{array}\right.
   $$
3. 设当前已确定与直线最近的像素点，坐标为$P(x_i,y_i)$，  
   下一个与直线最近的右方像素，只能是正右方像素$P_{RB}(x_i+1,y_i)$或右上方像素$P_{RU}(x_i+1,y_i+1)$，称为**两个“候选像素”**。  
4. $P_{RB}$和$P_{RU}$的中线$M$，易知坐标$M(x_i+1,y_i+0.5)$，  
   再假设$Q$为理想直线与垂直线$x=x_i+1$的交点，$M$与$Q$有三种关系：
   * 若$M$在$Q$上方或重合，则选正右方$P_{RB}$
   * 若$M$在$Q$下方，则选正右方$P_{RU}$
   ![M与Q三种关系](images/3.%E4%BA%8C%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95--09-22_08-16-51.png)  
   即用中点$M$的函数值$F(M)$作为决策变量$d_i$，根据$d_i$的符号确定下一个像素的选取。
   $$
   d_i\left\{\begin{array}{ll}
   <0 & \textrm { 取右上方像素 } P_{RU}\left(x_{i}+1, {y}_{i}+1\right) \textrm { 作为下一个像素 } \\
   \ge 0 & \textrm { 取正右方像素 } P_{RB}\left(x_{i}+1, {y}_{i}\right) \textrm { 作为下一个像素 }
   \end{array}\right.
   $$
5. 选择相应像素后，下一个决策变量可以直接推导出来：
   $$
   d_i\left\{\begin{array}{ll}
   <0 & d_{i+1}=d_i+a+b \\
   \ge 0 & d_{i+1}=d_i+a
   \end{array}\right.
   $$
6. 注意到初始的决策变量为$d_0=a+0.5b$，会造成$d_0$为浮点数，之后都是浮点数加法，  
   但$d$只需要关注大小位置，所以可以$\times2$，则**转换为整数加法**：
   * $d_0=2a+b$
   * $d_{i+1}=d_i+2a$或$d_{i+1}=d_{i}+2(a+b)$
7. 第一个像素要选择直线端点$P_0(x_0,y_0)$。  
   决策变量的定义在步骤4，初始的决策变量为$d_0=2a+b$。

> **注意 - 有关上述点与直线三种情况的补充：**
>
> 实际上判断点与直线位置情况应该是下面的判断式：  
> ![图 1](images/3.%E4%BA%8C%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95--09-25_18-38-19.png)  
> *出自于「[高中数学：点与直线的位置关系，点在直线上方、下方的条件不等式](https://www.zhihu.com/zvideo/1307370134743257088)」*
>
> 上面严格规定了$x_0<x_1$，即$b=x_1-x_0>0$，故才能直接化成上面的判断式。  
> 否则对于下面的情况，实际上是$F(M)>0$才在下方：  
> ![图 2](images/3.%E4%BA%8C%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95--09-25_18-39-42.png)  
> (这个时候$B<0$，在下方时$F(M)=d>0$)

**算法步骤：**

* 输入：两整数端点$P_0$和$P_1$，必要条件为$0\le k\le 1$，和画线的颜色$color$

1. 若$x_0>x_1$，交换两点
2. 设置初始像素坐标$x,y$为$x_0,y_0$
3. 计算系数$a$、$b$
4. 计算决策变量初始值$d_0 = 2a+b$，两种情况增量$delta1 = 2a$，$delta2 = 2a+2b$
5. 用循环确定沿线段下一像素位置，实现绘制：

   ```c++
   while (x != x1)
   {
     setpixel(x, y, color);
     if (d < 0)
       x++, y++, d += delta2;
     else
       x++, d += delta1;
   }
   ```

---

对于其他三种情况，就是根据$y=x,y=0,x=0$对称即可，这里只给出$d_i$迭代的操作与变化：

| $k$情况     | $k\in[0,1]$           | $k\in(1,+\infty)$     | $k\in[-1,0)$          | $k\in(-\infty,-1)$    |
| ------------- | --------------------- | --------------------- | --------------------- | --------------------- |
| $d_0$         | $d_0=2a+b$            | $d_0=a+2b$            | $d_0=2a-b$            | $d_0=a-2b$            |
| $d_i<0$情况 | `x++, y++, d+=2(a+b)` | `y++, d+=2b`          | `x++, d+=2a`          | `y--, x++, d+=2(a-b)` |
| $d_i\ge0$情况 | `x++, d+=2a`          | `y++, x++, d+=2(a+b)` | `x++, y--, d+=2(a-b)` | `y--, d+=2b`          |

**完整代码：**

```c++
void Line_Midpoint(int x0, int y0, int x1, int y1, Color color)
{
    if (x0 > x1) // 保证x0 <= x1
        swap(x0, x1), swap(y0, y1);
    int a = y0 - y1, b = x1 - x0,   // 直线L的参数（c因为没有用到不用计算）
        d,                          // 决策变量d
        dd_L, dd_G,                 // 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)
        x = x0, y = y0,             // 初始P坐标
        dPx_L, dPy_L, dPx_G, dPy_G; // P坐标的增量(L代表小于0的情况，G代表大于0的情况)
    // 根据k值分情况生成决策变量和增量
    if (-b <= a && a <= 0) // k ∈ [0, 1]
    {
        d = 2 * a + b;                            // d0 = 2a + b
        dPx_L = 1, dPy_L = 1, dd_L = 2 * (a + b); // d < 0情况
        dPx_G = 1, dPy_G = 0, dd_G = 2 * a;       // d >= 0 情况
    }
    else if (a < -b) // k ∈ (1, +∞)
    {
        d = a + 2 * b;                            // d0 = a + 2b
        dPx_L = 0, dPy_L = 1, dd_L = 2 * b;       // d < 0情况
        dPx_G = 1, dPy_G = 1, dd_G = 2 * (a + b); // d >= 0 情况
    }
    else if (0 < a && a <= b) // k ∈ [-1, 0)
    {
        d = 2 * a - b;                             // d0 = 2a - b
        dPx_L = 1, dPy_L = 0, dd_L = 2 * a;        // d < 0情况
        dPx_G = 1, dPy_G = -1, dd_G = 2 * (a - b); // d >= 0 情况
    }
    else // k ∈ (-∞, -1)
    {
        d = a - 2 * b;                                  // d0 = a - 2b
        dPx_L = 1, dPy_L = -1, dd_L = 2 * (a - b);      // d < 0情况
        dPx_G = 0, dPy_G = -1, dd_G = -2 * b;           // d >= 0 情况
    }
    // 迭代生成直线
    while (x != x1 || y != y1)
    {
        putpixel(x, y, color);
        d < 0 ? x += dPx_L, y += dPy_L, d += dd_L : x += dPx_G, y += dPy_G, d += dd_G;
    }
    putpixel(x, y, color);
}
```

### 4. Bresenham画线算法

其与中点画线算法的思想基本一致，只是在判断选$P_{RB}$和$P_{RU}$方法不同，  
这里把用实际位置与中点的位置关系，变为了与$P_{RB}$和$P_{RU}$两距离的大小关系，  
且约定$d_1=d_2$时选择右上方像素$P_{RU}$。  
仍先考虑$0\le k\le 1$的情况。

用$d_1$和$d_2$来表示正右$P_{RB}$和右上两个候选像素的$y$值，与线段上理想$y$值（$Q$点$y$值）的差值，  
即$d_1=|P_{RB}Q|, d_2=|P_{RU}Q|$，可得$d_1-d_2=2k(x_i+1)-2y_i+2b-1$，  
其中$k=\frac{\Delta y}{\Delta x}$，代入并在两边同乘$\Delta x$后得：
$$
\Delta x(d_1-d_2) = 2x_i\Delta y - 2y_i\Delta x + C
$$
其中$C$为一常量，$C=2\Delta y + \Delta x(2b-1)$。

设决策变量$d_i=\Delta x(d_1-d_2)$，其符号与$d_1-d_2$相同，起判别作用。  
判别情况如下：

$$
d_i\left\{\begin{array}{ll}
<0 & \textrm { 取正上方像素 } P_{LU}\left(x_i, {y}_{i}+1\right) \textrm { 作为下一个像素 } \\
\ge 0 & \textrm { 取右上方像素 } P_{RU}\left(x_{i}+1, {y}_{i+1}\right) \textrm { 作为下一个像素 }
\end{array}\right.
$$

而对于决策变量的迭代如下：
$$
d_{i+1}=2x_{i+1}\Delta y - 2y_{i+1}\Delta x + C \\
d_{i+1}-d_i = 2(x_{i+1}-x_i)\Delta y - 2(y_{i+1}-y_i)\Delta x \\
d_{i+1}=d_i+2\Delta y -2\Delta x(y_{i+1}-y_i)
$$

* 当$d_i<0$时，$y_{i+1}=y_i$，故$d_{i+1}=d_i+2\Delta y$
* 当$d_i\ge0$时，$y_{i+1}=y_i+1$，故$d_{i+1}=d_i+2(\Delta y - \Delta x)$

总结如下：

$$
d_i\left\{\begin{array}{ll}
<0 & \textrm { 取正上方像素 } P_{LU}\left(x_i, {y}_{i}+1\right) \textrm { 作为下一个像素 }, d_{i+1}=d_i+2\Delta y \\
\ge 0 & \textrm { 取右上方像素 } P_{RU}\left(x_{i}+1, {y}_{i+1}\right) \textrm { 作为下一个像素 }, d_{i+1} = d_i+2(\Delta y - \Delta x)
\end{array}\right.
$$

而对于决策变量初始值$d_0$，仍取左端点$P_0(x_0,y_0)$，计算得到$d_0$为：
$$
d_0 = 2x_0\Delta y - 2y_0\Delta x \\
C = 2\Delta y + \Delta x(2b-1) \\
b = y_0 - \frac{\Delta y}{\Delta x}x_0
$$

整理得：
$$
d_0 = 2\Delta y - \Delta x
$$

---

对于其他情况按中点画线法类似分析，可得到决策变量$d_i$每次迭代的处理如下表：

| $k$情况     | $k\in[0,1]$              | $k\in(1,+\infty)$        | $k\in[-1,0)$              | $k\in(-\infty,-1)$       |
| ------------- | ------------------------ | ------------------------ | ------------------------- | ------------------------ |
| $d_0$         | $d_0=2\Delta y-\Delta x$ | $d_0=2\Delta x-\Delta y$ | $d_0=-2\Delta y-\Delta x$ | $d_0=2\Delta x+\Delta y$ |
| $d_i<0$情况 | `x++, d+=2Δy`           | `y++, d+=2Δx`           | `x++, d+=-2Δy`           | `y--, d+=2Δx`           |
| $d_i\ge0$情况 | `x++, y++, d+=2(Δy-Δx)` | `x++, y++, d+=2(Δx-Δy)` | `x++, y--, d+=-2(Δy+Δx)` | `x++, y--, d+=2(Δx+Δy)` |

**算法代码：**

```c++
void Line_Bresenham(int x0, int y0, int x1, int y1, Color color)
{
    if (x0 > x1) // 保证x0 <= x1
        swap(x0, x1), swap(y0, y1);
    int Delta_x = x1 - x0, Delta_y = y1 - y0,
        d,                          // 决策变量d
        dd_L, dd_G,                 // 决策变量d的增量(L代表小于0的情况，G代表大于0的情况)
        x = x0, y = y0,             // 初始P坐标
        dPx_L, dPy_L, dPx_G, dPy_G; // P坐标的增量(L代表小于0的情况，G代表大于0的情况)
    // 根据k值分情况生成决策变量和增量
    if (0 <= Delta_y && Delta_y <= Delta_x) // k ∈ [0, 1]
    {
        d = 2 * Delta_y - Delta_x;                            // d0 = 2Δy - Δx
        dPx_L = 1, dPy_L = 0, dd_L = 2 * Delta_y;             // d < 0情况
        dPx_G = 1, dPy_G = 1, dd_G = 2 * (Delta_y - Delta_x); // d >= 0 情况
    }
    else if (Delta_x < Delta_y) // k ∈ (1, +∞)
    {
        d = 2 * Delta_x - Delta_y;                            // d0 = 2Δx - Δy
        dPx_L = 0, dPy_L = 1, dd_L = 2 * Delta_x;             // d < 0情况
        dPx_G = 1, dPy_G = 1, dd_G = 2 * (Delta_x - Delta_y); // d >= 0 情况
    }
    else if (-Delta_x <= Delta_y && Delta_y < 0) // k ∈ [-1, 0)
    {
        d = -2 * Delta_y - Delta_x;                             // d0 = -2Δy - Δx
        dPx_L = 1, dPy_L = 0, dd_L = -2 * Delta_y;              // d < 0情况
        dPx_G = 1, dPy_G = -1, dd_G = -2 * (Delta_y + Delta_x); // d >= 0 情况
    }
    else // k ∈ (-∞, -1)
    {
        d = 2 * Delta_x + Delta_y;                             // d0 = 2Δx + Δy
        dPx_L = 0, dPy_L = -1, dd_L = 2 * Delta_x;             // d < 0情况
        dPx_G = 1, dPy_G = -1, dd_G = 2 * (Delta_x + Delta_y); // d >= 0 情况
    }
    // 迭代生成直线
    while (x != x1 || y != y1)
    {
        putpixel(x, y, color);
        if (d < 0)
            x += dPx_L, y += dPy_L, d += dd_L;
        else
            x += dPx_G, y += dPy_G, d += dd_G;
    }
    putpixel(x, y, color);
}
```

## 二、圆和椭圆的扫描转换

### 1. 数学性质

* 数学意义上圆的定义：  
  给出中心$(x_c,y_c)$和半径$r$，则圆的方程为：
  $$
  (x-x_c)^2+(y-y_c)^2=r^2
  $$

三种生成方式：

* 直角坐标法生成圆：
  $$
  y=y_c+\sqrt{r^2-(x_c-x)^2}
  $$  
  * 方法：$x$从$x_c-r$到$x_c+r$以**单位步长**计算对应的两个$y$值。  
  * 问题：计算复杂、间隙不均匀（最左侧间隙大，中心处间隙小）
* 极坐标生成圆：  
  $$
  \left\{\begin{array}{l}
  x=x_{c}+r \cos \theta \\
  y=y_{c}+r \sin \theta
  \end{array}\right.
  $$
  * 方法：角度$\theta$在$0\sim360$范围均匀变化
  * 优点：解决了间隙不均匀。  
  * 问题：三角函数运算比平方根还要大。
* 八方对称法  
  定圆的四条对称轴，分为八个区域，确定一个区域的点，通过对称一步步生成其他七个点。  
  ![图 3](images/3.%E4%BA%8C%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95--09-22_09-07-47.png)  

  ```c++
  void CirclePoints(int xc, int yc, int x, int y, int color)
  {
      putpixel(xc + x, yc + y, color);
      putpixel(xc + y, yc + x, color);
      putpixel(xc - x, yc + y, color);
      putpixel(xc + y, yc - x, color);
      putpixel(xc + x, yc - y, color);
      putpixel(xc - y, yc + x, color);
      putpixel(xc - x, yc - y, color);
      putpixel(xc - y, yc - x, color);
  }
  ```

### 2. 中点生成

跟直线的中点画线法类似。

上述的八方对称法，规定生成最上方右侧的区域，对称生成其他的。  
则对于该区域，若从左至右生成，每个像素只能在正右方$P_{RU}$或右下方$P_{RB}$。

先**假定：圆心在原点**。

* 选两点的中点$M_i$的圆函数值$F(M_i)$作为决策变量$d_i$，两种情况：
  * $d_M<0$，取正右方像素$P_{RU}$，下一个决策变量$d_{i+1}=d_i+2x_i+3$  
  * $d_M\ge 0$，取右下方像素$P_{RB}$，下一个决策变量为$d_{i+1}=d_i+2(x_i-y_i)+5$
  
  注意这里的增量不是固定值，与$x_i,y_i$有关，故只能每次迭代计算。
* 初始决策变量$d_0$：定第一个像素$P_0$为正上方点$(0,R)$，  
  则两像素中点$M_0$为$(1,R-0.5)$，$d_0=1.25-R$  
* 同样转浮点数为整数，这里平移一个$-0.25$，用$d_i-0.25$代替$d_i$，转换为$d_0=1-R$  
  因为$R$为整数，$R=1$时原本为$0.25>0$，转换为$1-R$后为$0=0$，故把$d=0$归于$d_i>0$的情况，  
  其余仍按与$0$的关系来判断，且$d_{i+1}$迭代式不变。


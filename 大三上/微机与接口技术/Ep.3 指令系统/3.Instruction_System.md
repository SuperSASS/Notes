# Ep.3 8086的寻址方式与指令系统

1. 有哪些寻址方式？
2. 每一种寻址方式如何得到操作数的地址？

## 一、概述

### 1. 指令

指令包含两部分：

* 操作码
* 操作数：可以为真实的**数据**，也可以为数所在内存单元的**地址**。

格式：

* 无操作数指令
* 多操作数指令（两个操作数称为双操作数或二地址指令）

> 举例 - 指令格式：
>
> * 无操作数格式：`CLI` - 清IF位
> * 单操作数格式：`INC AX` - (AX)+1→AX
> * 双操作数格式：`MOV ES, BX` - (BX)→ES（ES是目的操作数，BX是源操作数）
> * 双操作数格式：`ADD AX, [BX]` - (DS:(BX))+(AX)→AX（BX是偏移地址，与DS搭配）

### 2. 寻址技术

寻址技术是通过数据寻址方式的设定，压缩指令长度，并且灵活的寻找操作数地址；是**操作数地址**表示的一种方式。

产生不同寻址技术的原因：

* 操作数地址**表示多样化**需要
* **压缩**操作数地址字段的长度

## 二、寻址技术

七种寻址方式：

* 立即寻址
* 寄存器寻址
* 直接寻址
* 寄存器间接寻址
* 寄存器相对寻址
* 基址变址寻址
* 相对基址变址寻址

前两者直接给出操作数，后面的均给出地址。

对于一个多操作数指令，**不同的操作数**可能采用**不同的寻址方式**。

以下均以`MOV Des, Res`指令为例讲解寻址方式。
需要保证源操作数与目的操作数**位数一致**，否则无法存放（如不能将AX存放到BL中）。

### 1. 立即寻址

操作数**直接出现在指令**中。  
此时操作数直接存放在跟指令一起的**代码段**中，紧跟在操作码后面。

```asm
MOV AL, 1AH;   % 1AH→AL
MOV AX, 2010H; % 2010H→AX
```

对于2字节数据`2010H`，其在操作码后先存放`10H`、再存放`20H`。

### 2. 寄存器寻址

操作数在指令**指定的寄存器**中。  

优点：

* 操作数在 CPU 内部的寄存器中，指令执行不需要访存**速度快**
* 寄存器号短（一共14个寄存器，就$0~14$），指令机器码**长度短**。

可以出现的寄存器：

* 16位数据：AX/BX/CX/DX、SI/DI/SP/BP、CS/DS/SS/ES
* 8位数据：AH/AL、BH/BL、CH/CL、DH/DL

条件：

* 两个操作数不能同时是段寄存器(CS/DS/SS/ES)
* 目标操作数不能是代码段寄存器(CS)（因为里面存放的要执行的指令，不能随意改写）

### 3. 直接寻址

操作数在**存储器（内存）**中。
指令给出的是操作数在内存的**偏移地址**（有效）$EA$。

为了与立即寻址区别，该有效地址必须用`[]`括起（即**看到`[]`就代表有效地址**）。

除了用数字加方括号的形式`[xxxxH]`，也可以以用用户自定义符号表示`LABLE`，  
如：`MOV AL, LABLE`。  
若符号带有运算，也算直接寻址。（如举例第四个）x`

需要注意：没有特殊说明，直接寻址的操作数一般**在内存的数据段**中，即**隐含的段寄存器是DS**。  
即需要将有效地址加上段寄存器，得到物理地址。
*对于机组中学的，应该也是隐含在数据段的（因为不可能取其他段的数据，如自检程序）。*

```asm
MOV AX, [2020H];  % (DS:2020H)→AL, (DS:2020H+1)→AH
MOV BH, ES:[10H]; % (ES:10H)→BH
MOV AL, LABLE;    % (DS:LABLE)→AL
MOV AL, LABLE+5;  % (DS:LABLE+5)→AL
```

### 4. 寄存器间接寻址

操作数的有效地址EA存放在寄存器中。  
寄存器名用`[]`括起。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

```asm
MOV AX, [BX];    % (DS:EA)→AL, (DS:EA+1)→AH，其中EA=(BX)
MOV AL, ES:[BX]; % (ES:EA)→AL，其中EA=(BX)
MOV AX, [BP];    % (SS:EA)→AL, (SS:EA+1)→AH，其中EA=(BP)
```

### 5. 寄存器相对寻址

*看到相对，即加了数字的偏移量。*

操作数的有效地址EA是：指令中**指定的基址或变址寄存器**的值，与**位移量**之和。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

偏移量：**有符号数**，可以为8位或16位。

位移量三种等效表示方式：

* `MOV AX, 8[BX]`
* `MOV AX, [BX]+8`
* `MOV AX, [BX+8]`

```asm
MOV AX, 8[BX]; % (DS:EA+8)→AL, (DS:EA+8+1)→AH, 其中EA=(BX)
```

### 6. 基址变址寻址

操作数的有效地址EA是：指令中指定的**基址寄存器**的值，与**变址寄存器**的值之和。  

可用基址寄存器同上。  
可用变址寄存器只有2个：

* BX - 在数据段
* BP - 在堆栈段

格式：`[基址寄存器][变址寄存器]`

```asm
MOV AX, [BX][SI]
```

### 7. 相对基址变址寻址

就是基址变址基础上，再加上个偏移量

```asm
MOV AX, 3[BX][SI]
```

---

## 一、语言

### 1. 机器语言

由二进制代码组成，唯一能被 CPU 识别执行。  
每一条称为指令，所能识别的所有指令集合为指令系统。

指令是计算机能够执行的最小功能单位，程序就是由一条条指令按一定顺序组织起来的**指令序列**。

### 2. 汇编语言

是一种符号语言，将机器语言的二进制数用符号替换表示。

汇编语言编制的程序为“汇编语言源程序”，计算机不能直接识别执行，  
需要翻译成机器语言，过程称为汇编，完成汇编工作的程序为汇编程序。


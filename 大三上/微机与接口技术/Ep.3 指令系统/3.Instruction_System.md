# Ep.3 8086的寻址方式与指令系统

1. 有哪些寻址方式？
2. 每一种寻址方式如何得到操作数的地址？

## 一、概述

### 1. 指令

指令包含两部分：

* 操作码
* 操作数：可以为真实的**数据**，也可以为数所在内存单元的**地址**。

格式：

* 无操作数指令
* 多操作数指令（两个操作数称为双操作数或二地址指令）

> 举例 - 指令格式：
>
> * 无操作数格式：`CLI` - 清IF位
> * 单操作数格式：`INC AX` - (AX)+1→AX
> * 双操作数格式：`MOV ES, BX` - (BX)→ES（ES是目的操作数，BX是源操作数）
> * 双操作数格式：`ADD AX, [BX]` - (DS:(BX))+(AX)→AX（BX是偏移地址，与DS搭配）

### 2. 寻址技术

寻址技术是通过数据寻址方式的设定，压缩指令长度，并且灵活的寻找操作数地址；是**操作数地址**表示的一种方式。

产生不同寻址技术的原因：

* 操作数地址**表示多样化**需要
* **压缩**操作数地址字段的长度

## 二、寻址技术

七种寻址方式：

* 立即寻址
* 寄存器寻址
* 直接寻址
* 寄存器间接寻址
* 寄存器相对寻址
* 基址变址寻址
* 相对基址变址寻址

前两者直接给出操作数，后面的均给出地址。

对于一个多操作数指令，**不同的操作数**可能采用**不同的寻址方式**。

以下均以`MOV Des, Res`指令为例讲解寻址方式。
需要保证源操作数与目的操作数**位数一致**，否则无法存放（如不能将AX存放到BL中）。

### 1. 立即寻址

操作数**直接出现在指令**中。  
此时操作数直接存放在跟指令一起的**代码段**中，紧跟在操作码后面。

```asm
MOV AL, 1AH;   % 1AH→AL
MOV AX, 2010H; % 2010H→AX
```

对于2字节数据`2010H`，其在操作码后先存放`10H`、再存放`20H`。

注意：对于段寄存器如`DS`，约定不能直接赋值，需要用寄存器如`AX`中转。

### 2. 寄存器寻址

操作数在指令**指定的寄存器**中。  

优点：

* 操作数在 CPU 内部的寄存器中，指令执行不需要访存**速度快**
* 寄存器号短（一共14个寄存器，就$0~14$），指令机器码**长度短**。

可以出现的寄存器：

* 16位数据：AX/BX/CX/DX、SI/DI/SP/BP、CS/DS/SS/ES
* 8位数据：AH/AL、BH/BL、CH/CL、DH/DL

条件：

* 两个操作数不能同时是段寄存器(CS/DS/SS/ES)
* 目标操作数不能是代码段寄存器(CS)（因为里面存放的要执行的指令，不能随意改写）

### 3. 直接寻址

操作数在**存储器（内存）**中。
指令给出的是操作数在内存的**偏移地址**（有效）$EA$。

为了与立即寻址区别，该有效地址必须用`[]`括起（即**看到`[]`就代表偏移地址**）。

除了用数字加方括号的形式`[xxxxH]`，也可以以用用户自定义符号表示`LABLE`，  
如：`MOV AL, LABLE`。  
若符号带有运算，也算直接寻址。（如举例第四个）x`

需要注意：没有特殊说明，直接寻址的操作数一般**在内存的数据段**中，即**隐含的段寄存器是DS**。  
即需要将有效地址加上段寄存器，得到物理地址。
*对于机组中学的，应该也是隐含在数据段的（因为不可能取其他段的数据，如自检程序）。*

```asm
MOV AX, [2020H];  % (DS:2020H)→AL, (DS:2020H+1)→AH
MOV BH, ES:[10H]; % (ES:10H)→BH
MOV AL, LABLE;    % (DS:LABLE)→AL
MOV AL, LABLE+5;  % (DS:LABLE+5)→AL
```

### 4. 寄存器间接寻址

操作数的有效地址EA存放在寄存器中。  
寄存器名用`[]`括起。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

```asm
MOV AX, [BX];    % (DS:EA)→AL, (DS:EA+1)→AH，其中EA=(BX)
MOV AL, ES:[BX]; % (ES:EA)→AL，其中EA=(BX)
MOV AX, [BP];    % (SS:EA)→AL, (SS:EA+1)→AH，其中EA=(BP)
```

### 5. 寄存器相对寻址

*看到相对，即加了数字的偏移量。*

操作数的有效地址EA是：指令中**指定的基址或变址寄存器**的值，与**位移量**之和。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

偏移量：**有符号数**，可以为8位或16位。

位移量三种等效表示方式：

* `MOV AX, 8[BX]`
* `MOV AX, [BX]+8`
* `MOV AX, [BX+8]`

```asm
MOV AX, 8[BX]; % (DS:EA+8)→AL, (DS:EA+8+1)→AH, 其中EA=(BX)
```

### 6. 基址变址寻址

操作数的有效地址EA是：指令中指定的**基址寄存器**的值，与**变址寄存器**的值之和。  

可用基址寄存器同上。  
可用变址寄存器只有2个：

* BX - 在数据段
* BP - 在堆栈段

格式：`[基址寄存器][变址寄存器]`

```asm
MOV AX, [BX][SI]
```

### 7. 相对基址变址寻址

就是基址变址基础上，再加上个偏移量

```asm
MOV AX, 3[BX][SI]
```

## 三、拓展

任何处理器都主要确定两个问题：

* 数据在哪里
* 处理数据长度

用reg代表寄存器，sreg代表段寄存器。

对于8086：

* reg: AX, BX, CX, DX, SP, BP, SI, DI
* sreg: SS, CS, DS, ES

对于`[]`这种偏移地址，**只能用**bx、si、di、bp，  
且组合方式为：[(bx/bp)(si/di)]

对于处理数据长度，可以直接在指令中给出（指根据寄存器的长度来定）。  
比如`mov AX, ...`，其中`AX`就说明了操作的为字（16位）。

也可以直接指明，如用`word ptr`/`byte ptr`，表示访问的内存单元是1字。  
比如`inc word ptr AX`。  
对于没有寄存器参与的内存单元访问指令中，直接指明尤其必要。

还有些指令默认了数据长度，  
如`push`,`pop`，其只进行字操作。

## 四、8086指令系统

包括六大类指令：

* 数据传送指令  
* 算数运算指令
* 逻辑运算和位移指令
* 串操作指令
* 控制转移指令
* 处理器控制指令

### 1. 数据传送指令

* 除了`POPF`和`SHAF`，其他指令执行结果都**不影响标志位**。
* 如果列出两个操作数，执行过程：目标操作数←源操作数；如果列出一个操作数，另一个为隐含操作数

#### (1) MOV

#### (2) PUSH

* 操作：将自定的操作数压入堆栈，栈指针SP减2。

  ```asm
  (SP) ← (SP)-2
  (SP)-1 ← 操作数高字节
  (SP)-2 ← 操作数低字节
  ```

* 约束：`PUSH`指令总是把**2个字节**一起压入堆栈。

#### (3) POP

* 操作：将堆栈顶部2个字节弹出，栈指针SP加2.

  ```asm
  操作数高字节 ← (SP)
  操作数低字节 ← (SP)+1
  (SP) ← (SP)+2
  ```

#### (4) XCHG - 交换

* 操作：目的操作数的内容和源操作数的内容交换。
* 约束：`XCHG`不能对段寄存器进行内容交换。

#### (5) XLAT - 换码

是“累加器低位AL专用传输指令”。

* 操作：把数据段中偏移地址为BX+AL的内存单元的内容送到AL中。  
  即：$(AL)\leftarrow (BX+AL)$
* 说明：把内容表格中某一单元的值传送到寄存器AL（用于对照某表进行转码）。  
  比如对于ASCII码表中的'a'，AL为97，使用指令后则能找到为'a'。
* 约束：
  * 源操作数与目的操作数均隐含
  * BX存内存表格首地址，AL存表格偏移量
  * 数据长度为字节，最大容量256。

#### (6) LEA - 取偏移地址指令

* 操作：把变量、标号或表达式所指的内存单元的偏移地址，送到指定寄存器。
* 约束：源操作数必须为存储器地址，目的操作数必须为16位的通用寄存器。

如`LEA DI, [BX+SI]`，其中BX=`100H`，SI=`10H`，则DI=`110H`

#### (7) LDS - 地址指针装入DS指令

#### (8) LES - 地址指针装入ES指令

#### (9) LAHF - 取标志指令

#### (10) SAHF - 置标志指令

* 操作：将AH的内容写入标志寄存器0~7位。

#### (11) PUSHF - 标志入栈指令

#### (12) POPF - 标志出栈指令

#### 5. 数据类型转换指令

1. `CBW` - 字节转换为字指令
2. `CWD` - 字转双字指令  
   * 操作：把寄存器**AX**中数据的符号位扩展到**DX**寄存器中。

### 2. 算数运算指令

完成的操作有五种：加法、减法、乘法、除法和十进制调整。

特点：

* 大多数对标志位产生影响。
* 操作数有一个或两个。
* 必须**有一个操作数在寄存器**中（双操作数允许源操作数是立即数，单操作数只允许为寄存器）。

#### (1) 加法指令

* `ADD` - 加法指令
  * 格式：

    ```asm
    ADD dest, src
    ; e.g.
    ; ADD CX, DI
    ; ADD [BP], CL
    ; ADD CL, TEMP
    ; ADD BYTE PTR [DI], 3
    ```
  
  * 
* `ADC` - 带进位位的加法指令  
  使用前要将CF清零。  
  如果两操作数位数不一样，要进行符号扩展。
* `INC` - 加1指令  
  不影响CF进位标志位。

#### (2) 减法指令

* `SUB` - 减法指令  
  位数不同，符号扩展
* `SBB` - 带借位的减法  
  先将CF清零。
* `DEC` - 减1指令。
  不影响CF进位标志位。
* `CMP` - 比较指令  
  左侧（目的操作数）减右侧（源操作数），结果只保存在标志寄存器中，不返回。  
  搭配各种转移指令用。
* `NEG`

#### (3) 乘法指令

* `MUL` - 无符号数的乘法  
  对于8位  
  对于16位

---

## 一、语言

### 1. 机器语言

由二进制代码组成，唯一能被 CPU 识别执行。  
每一条称为指令，所能识别的所有指令集合为指令系统。

指令是计算机能够执行的最小功能单位，程序就是由一条条指令按一定顺序组织起来的**指令序列**。

### 2. 汇编语言

是一种符号语言，将机器语言的二进制数用符号替换表示。

汇编语言编制的程序为“汇编语言源程序”，计算机不能直接识别执行，  
需要翻译成机器语言，过程称为汇编，完成汇编工作的程序为汇编程序。


# 第二节 8086的指令系统

包括六大类指令：

* 数据传送指令  
* 算术运算指令
* 逻辑运算和位运算指令
* 串操作指令
* 控制转移指令
* 处理器控制指令

对于存储器需注意的两点：

1. 存储器每个存储单元容量为1byte(8bit)
2. 存储器采用**小端方案**，即低字节在前（小地址），高字节在后（大地址）。  
   如对于16位数`24_5FH`，若存放首地址是`1000H`，则`(1000H)=5FH`、`(1001H)=24H`。

## 一、数据传送指令

将数据或地址传送到寄存器、存储单元或I/O口中。

**分类**：

* 通用数据传送指令
* 累加器专用传送指令
* 地址传送指令
* 标志传送指令
* 数据类型转换指令

**特点**：

* 除了`POPF`和`SHAF`，其他指令执行结果都**不影响标志位**。
* 如果列出两个操作数，执行过程：目标操作数←源操作数；如果列出一个操作数，另一个为隐含操作数

### 1. 通用数据传送指令

| 名称       | 指令          | 功能                           |
| ------------ | --------------- | -------------------------------- |
| 传送指令 | `MOV dest, src`  | `(src)`（一字或字节）传送到`dest` |
| 数据交换指令 | `XCHG dest, src` | `(src)`与`(dest)`互换          |
| 进栈指令 | `PUSH src`      | `src`入栈                      |
| 出栈指令 | `POP dest`       | 数据出栈，存入`dest`       |

#### (1) 传送指令 - MOV

**格式**：`MOV dest, src`

**功能**：将`src`的内容（一字或字节）传送到`dest`指定的reg或mem，`src`内容不变。

**约束**：

* 源操作数`src`：可以是imm(立即数)、reg(寄存器)或mem(内存中的操作数)。
* 目标操作数`dest`：可以是reg或mem（不允许为imm和**CS寄存器**）。
* IP和FR(FLAGS)不允许作为`dest`和`src`。
* imm不允许直接传到DS、ES或SS寄存器（传到这三个sreg，需要经过reg或mem中转）。
* `src`和`dest`**不允许同时**是mem或sreg。
* `src`和`dest`数据类型必须相同，同为byte或word。

**举例**：

```asm
; 合法
MOV AL, 5          ; byte, reg ← imm
MOV AX, BX         ; word, reg ← reg
MOV DS, AX         ; word, sreg ← reg

; 非法
MOV AX, BL         ; 数据类型不一致
MOV CS, AX         ; CS不能作为dest
MOV DS, 2010H      ; 立即数不能直接送到段寄存器
MOV [BX], [1000H]  ; src,dest不能都是mem
```

#### (2) 数据交换指令 - XCHG

**格式**：`XCHG dest, src`

**功能**：`src`的内容（一字或字节）与`dest`的内容（对应的一字或字节）互换。

**约束**：

* `dest`和`src`都可以是reg或mem，不可以是sreg、IP、imm。
* `dest`和`src`不可以同时是mem或AX(累加器)。

**举例**：

```asm
; 合法
XCHG BL, AH               ; byte, reg ← reg
XCHG AX, [BX][SI]         ; word, reg ← mem

; 非法
XCHG AX, 2010H            ; imm不能作为dest或src
XCHG CS, 5[SI]            ; sreg不能作为dest或src
XCHG [2010H], [2011H]     ; 不能同时是mem或AX
XCHG AX, AX               ; 不能同时是mem或AX
```

#### (3) (堆栈操作指令)进栈指令 - PUSH

堆栈段中，段地址由SS指示，栈顶偏移地址由SP(堆栈指针寄存器)指示。  
堆栈操作指令**数据类型只能是word**，且**imm不能作为操作数**。

堆栈的栈底是在大地址，栈顶是小地址，  
若`00000H`在上，则是下方向上方扩栈。

SP指向的当前地址(SP)和下一个地址(SP+1)为栈顶字16位数据。

---

**格式**：`PUSH src`

**功能**：`src`入栈。

**约束**：

* `src`可以是**sreg**、reg或mem。

**操作**：将指定的操作数压入堆栈，栈指针SP减2。  

1. `SP ← (SP)-2`
2. `SS:SP ← (src_low)`（如`src`是mem，则`src_low=(mem)`）
3. `SS:SP+1 ← (src_high)`（如`src`是mem，则`src_low=(mem+1)`）

**举例**：

```asm
; 合法
PUSH AX       ; word, reg入栈（SP-2后，reg_low传入SP；reg_high传入SP+1）
PUSH [2000H]  ; word, mem入栈（SP-2后，2000H传入SP；2001H传入SP+1）
PUSH CS       ; word, sreg入栈

; 非法
PUSH AL       ; 数据类型不能为byte（POP同）
PUSH 2000H    ; imm不能作为操作数（POP同）
```

![图 1](images/3.2-Address%26Instruction-2--10-14_13-11-11.png)

#### (4) (堆栈操作指令)出栈指令 - POP

**格式**：`POP dest`

**功能**：数据出栈，存入`dest`。

**约束**：

* `dest`可以是**sreg(除CS)**、reg(16bit)或mem。

**操作**：将指定的操作数压入堆栈，栈指针SP减2。  

1. `dest_low ← (SS:SP)`
2. `dest_high ← (SS:SP+1)`
3. `SP ← (SP)+2`

**举例**：

```asm
; 合法
POP SS       ; word, 出栈到sreg（(SP)传入SS_low；(SP+1)传入SS_high，SP+2）
POP [2000H]  ; word, 出栈到mem（(SP)传入2000H；(SP+1)传入2001H，SP+2）

; 非法
PUSH CS      ; CS不能作为dest
```

### 2. 累加器专用传送指令

| 名称   | 指令                                     | 功能                                           |
| -------- | ------------------------------------------ | ------------------------------------------------ |
| 换码指令 | `XLAT` / `XLAT addr`                       | 将内存表格（表格首地址为BX）中指定单元的值送至AL |
| 输入指令 | `IN AL(/AX), addr_IO` / `IN AL(/AX), DX`   | 从指定的I/O端口读入到AX(16bit)或AL(8bit) |
| 输出指令 | `OUT addr_IO, AL(/AX)` / `OUT DX, AL(/AX)` | 将AX(16bit)或AL(8bit)输出到指定的I/O端口 |

#### (1) 换码指令 - XLAT

**格式**：

* `XLAT`
* `XLAT addr`

**功能**：将内存表格中指定单元的指传送至AL。

**约束**：

* `src`和`dest`均隐含
* **BX**保存**内存表格首地址**，**AL**保存某**数据**在此表格中**偏移量**，  
  使用指令前，必须初始化BX和AL两个reg。
* 内存表格的数据类型**只能是byte**。
* 内存表格的最大容量是256byte（因为偏移量AL为8bit）。
* 格式2中的`addr`，**只是为了提高可读性**设置的，  
  执行操作时，**实际上是**先`BX ← (addr)`，再`XLAT`。

**操作**：`AL ← (BX+AL)`
  
**作用**：比如对于ASCII码表中的'a'，AL为97，使用指令后则能找到为'a'。

#### (2) (I/O指令)输入指令 - IN

I/O指令用于CPU和I/O端口之间进行数据传送。

---

**格式**：

* `IN AL, addr_IO`
* `IN AX, addr_IO`
* `IN AL, DX`
* `IN AX, DX`

**功能**：从指令中指定的I/O端口，读入一byte数据到AL（或一word数据到AX）。

**约束**：

* 采用格式1和格式2时，`addr_IO`的取值范围之`0 ~ FFH`，可以寻256个I/O端口。
* I/O端口地址值超过`FFH`时，只能采用格式3和格式4，  
  将地址保存到DX中，则寻址范围为`0 ~ FFFFH`，可以寻65536个I/O端口。
* 访问8bit的I/O端口时，`dest`选用AL；  
  访问16bit的I/O端口时，`dest`选用AX。

#### (2) (I/O指令)输出指令 - OUT

**格式**：

* `OUT addr_IO, AL`
* `OUT addr_IO, AX`
* `OUT DX, AL`
* `OUT DX, AX`

**功能**：将AL(AX)内容输出到一个8bit(16bit)的I/O端口。

**约束**：*同`IN`指令。*

### 3. 地址传送指令

汇编程序中，addr是一种特殊操作数，区别于一般数据操作数，其是16bit无符号数。  
为了突出addr的特点，故用专门的指令进行地址传送。

#### (1) 取偏移地址指令 - LEA

**格式**：`LEA reg_16, addr_mem`

**功能**：取变量、标号或表达式**所指的mem的偏移地址**（而非mem本身内容），送到16bit的寄存器reg_16中。

**约束**：

* `src`必须为存储器的**地址**。
* `dest`必须为**16位**的**通用寄存器**。

**操作**：`reg_16 ← EA(mem)`

**举例**：

```asm
LEA DI, [BX+SI]
```

设`(DS) = 2100H`、`(BX)+(SI) = 110H`、`(DS:110H) = 1234H`，  
执行后，`(DI) = (BX)+(SI) = 110H`。

#### (2) 地址指针装入DS指令 - LDS

**格式**：`LDS reg_16, mem_32`

**功能**：将内存中32位`src`中，低16bit（小地址）送到`reg_16`中，高16bit（大地址）送到**段寄存器DS**中。

**操作**：

1. `reg_16 ← mem_32_low`(`mem_32_low`即`(men_32)`)
2. `DS ← mem_32_high`（`mem_32_high`即`(mem_32+2)`）

**举例**：

```asm
LDS AX, [BX+SI]
```

设`(DS) = 2100H`、`(BX)+(SI) = 110H`、`(DS:110H) = 1234H`、`(DS:112H) = 9876H`，  
执行后，`(AX) = (DS:110H) = 1234H`、`(DI) = (DS:110H+2H) = 9876H`。

#### (3) 地址指针装入ES指令 - LES

**格式**：`LES reg_16, mem_32`

*只是将`LDS`中的DS改为ES，其余相同。*

### 4. 标志传送指令

#### (1) 取标志指令 - LAHF

**格式**：`LAHF`

**功能**：

**约束**：

**操作**：

**举例**：

#### (2) 置标志指令 - SAHF

**格式**：`SAHF`

**功能**：

**约束**：

**操作**：将AH的内容写入标志寄存器0~7位。

**举例**：

#### (3) 标志入栈指令 - PUSHF

**格式**：`PUSHF`

**功能**：

**约束**：

**操作**：

* `SP ← (SP) - 2`
* `(SP+1, SP) ← PSW`

**举例**：

#### (4) 标志出栈指令 - POPF

**格式**：`POPF`

**功能**：

**约束**：

**操作**：

* `PSW ← (SP+1, SP)`
* `SP ← (SP) + 2`

**举例**：

### 5. 数据类型转换指令

#### (1) 字节转换为字指令 - CBW

**格式**：`CBW`

**功能**：把寄存器`AL`中数据，通过符号位扩展到`AH`寄存器中，使字节byte转换为字word。

一个用补码表示的数，经过`CBW`扩展后，数值大小不变。

**操作**：

* `AL < 80H`，则`AH ← 00H`（最高位为`0`，符号位扩展全`0`）
  `AL >= 80H`，则`AH ← FFH`（最高位为`1`，符号位扩展全`1`）

注意，只对`AL`进行扩展为`AX`。

#### (2) 字转双字指令 - CWD

**格式**：`CWD`

**功能**：把寄存器`AX`中数据，通过符号位扩展到`DX`寄存器中，使字转换为双字。

一个用补码表示的数，经过`CBD`扩展后，数值大小不变。

**操作**：

* `AX < 8000H`，则`DX ← 0000H`（最高位为`0`，符号位扩展全`0`）
  `AX >= 8000H`，则`DX ← FFFFH`（最高位为`1`，符号位扩展全`1`）

注意，只对`AX`进行扩展为`DX_AX`。

## 二、算数运算指令

就是用来执行算术运算。

**分类：**

* 加法指令
* 减法指令
* 乘法指令
* 除法指令
* 十进制调整指令

**特点：**

* 大多数对标志位产生影响。
* 操作数有一个或两个。
* 必须**有一个操作数在寄存器**中（双操作数允许源操作数是立即数，单操作数只允许为寄存器）。

### 1. 加法/减法指令

#### (1) 不管进位加法/减法指令 - ADD/SUB

**格式**：`ADD/SUB dest, src`

**约束**：

* 如果遇到要把`reg/mem`字word和一个`imm`字节byte相加，那么加之前，先要把`imm`byte扩展为word（16位）

**举例**：

```asm
ADD CX, DI
ADD [BP], CL ; 会将BP开始一byte加上CL
ADD [BP], CX ; 会将BP开始一word加上CX ([BP]+CL, [BP+1]+CH)
ADD CL, TEMP
ADD BYTE PTR [DI], 3
```

#### (2) 带进位位的加法/减法指令 - ADC/SBB

**操作**：不仅进行相加，还要加上`CF`标志位。

**约束**：同`ADD`

使用前要将CF清零（确保真的要加`CF`）。  
如果两操作数位数不一样，要进行符号扩展。

#### (3) 加/减1指令 - INC/DEC

**格式**：`INC/DEC dest`

不影响`CF`进位标志位（不产生进位）。

#### (4) 比较指令 - CMP

**格式**：`CMP dest, src`

**功能**：

左侧(dest)减右侧(src)，结果只保存在标志寄存器中，不返回。  
主要用于搭配**各种转移指令**。

**约束**：

* 目标操作数`dest`：可以是reg或mem。
* 源操作数`src`：可以是imm(立即数)、reg(寄存器)或mem(内存中的操作数)。
* 对于无符号数相减：考虑ZF（判零）和CF（借位）
* 对于有符号数相减：考虑ZF（判零）和OF（溢出）、SF（符号）  
  不溢出时(`OF=0`)，若`SF=0`（结果为正），则$dest>src$；  
  溢出时(`OF=1`)，若`SF=1`（结果为负），则$dest>src$。

**举例**：

```asm
CMP AL, 0   ; AL - 0
```

#### (5) 求补指令 - NEG

**格式**：`NEG dest`

就是求`dest`的变补，即补码的相反数。  

**操作**：
将`dest`各位取反加`1`。

`X + Y = X - NEG(Y)`

### 2. 乘法指令

#### (1) 无符号数乘法 - MUL

**格式**：`MUL src`

**功能**：将`src`（为reg），若`src`为byte，与`AL`相乘存放到`AX`；若`src`为word，与`AX`相乘，存放到`DX_AX`

会影响`CF`和`OF`：若`CF=OF=1`，表示`AH`/`DX`为有效数据（乘法结果用到这两个）；若`CF=OF=0`，则为无效数据（结果没超过用这两个表示的范围）。

**约束**：

* `src`不能为imm

**操作**：

* 对于8位无符号数`src`：将`AL`与`src`无符号数直接相乘，然后结果存放到`AX`  
* 对于16位：将`AX`与`src`无符号数直接相乘，然后结果存放到`DX_AX`

#### (2) 有符号数乘法 - IMUL

几乎类似于`MUL`，但就是把数当成了有符号数，然后计算的结果是有符号数相乘的结果。

如：`AL = 7FH`(127/127),`BL = 80H`(128/-128)（前者为无符号数，后者为有符号数）

* `MUL AL`，则`AX = 3F80`(16256)
* `IMUL AL`，则`AX = C080`(-16256)

### 3. 除法指令

![图 3](images/3.2-Address%26Instruction-2--03-03_21-13-01.png)

### 4. 十进制调整指令

![图 4](images/3.2-Address%26Instruction-2--03-03_22-00-07.png)

就是当存储十六进制就代表这个数时，做运算就带调整指令。  
比如某一地址十六进制为`38H`，其就代表数38，而不是十进制的56。

## 三、逻辑运算和位运算指令

### 1. 逻辑运算指令

基本的逻辑运算如下4个：

* `AND` - 与
* `OR` - 或
* `NOT` - 非
* `XOR` - 异或（相异取`1`）

#### (1) 逻辑测试指令 - TEST（不返回与）

**格式**：`TEST dest, src`

**功能**：

将`dest`与`src`**相与**，但**只影响标志位**，不返回结果。  
对标志位影响：`CF`、`OF`清0；根据结果影响`SF`、`ZF`、`PF`；AF值不定。

**操作**：`(dest) ^ (src)`

### 2. 各类位移指令

![图 1](images/3.2-Address%26Instruction-2--02-27_10-56-47.png)

* 逻辑左移 - `SHL`
  逻辑右移 - `SHR`
* 算术左移 - `SAL`
  算术右移 - `SAR`

![图 2](images/3.2-Address%26Instruction-2--02-27_10-57-22.png)  

* 不带进位 位循环左移 - `ROL`
  不带进位 位循环右移 - `ROR`
* 带进位 位循环左移 - `RCL`
  带进位 位循环右移 - `RCR`

格式均为：`SHL dest, CNT(1/CL)`，  
其中：

* `CNT`表示移动次数，注意！当$CNT>1$时，必须使用`CL`寄存器说明
* 全会改变标志
  * `ZF`
  * `SF`(符号)
  * `PF`(奇偶)
  * `CF`(进位)
  * `OF`(溢出、`CNT=1`时符号为改变置`1`；`CNT>1`时不改变)
  * *循环位移还会改变`AF`

## 四、串操作指令

* `MOVS(B/W)` - 串传送  
  `MOVSB`以byte为长度；`MOVSW`以word为长度，下同  
  一般搭配`REP`前缀。
* `CMPS(B/W)` - 串比较  
  每次做两串当前位的`CMP`（相减）  
  一般搭配`REPE/REPNE`前缀。
* `SCAS(B/W)` - 串扫描  
  找到目的串`ED:DI`中，与`AL/AX`相等或不等的地址。  
  一般搭配`REPE/REPNE`前缀。
* `LODS(B/W)` - 串加载  
  将源串`DS:SI`的字节或字，存入`AL/AX`。  
  不搭配前缀，而在一般循环中调用。
* `STOS(B/W)` - 串存储  
  将`AL/AX`，存入目的串`ES:DI`的字节或字。  
  不搭配前缀，而在一般循环中调用。

**特点**：

* 源串`src`一般存放在数据段`DS`，偏移地址由`SI`指定，即`DS:SI`
* 目标串`dest`**必须**在附加段`ES`，偏移地址由`DI`指定，即`ES:DI`
* 串的长度由`CX`决定
* 串的方向由`DF`决定，`DF=0`为自增；`DF=1`为自减  
  根据操作的是字还是字节，在执行完后会自动会`SI, DI`自加或自减1或2

**前缀指令 - `REP`系**：

![图 5](images/3.2-Address%26Instruction-2--03-03_22-38-30.png)

## 五、控制转移指令

8086中程序(Code)的执行，是由代码寄存器CS和指令指针寄存器IP共同决定，  
计算方法：$CS \times 10H + IP$。

一般来说是按顺序执行，  
但通过控制转移指令，可以改变CS和IP，从而改变执行顺序。

可以分为“段内转移指令”和“段间转移指令”，  
段内转移指令，指程序在同一代码段内，只有IP改变；  
段间转移指令，指程序将转移到其它段，CS和IP均改变。

**分类**：

* 无条件转移指令
* 条件转移指令
* 循环控制指令
* 过程调用与返回指令
* 中断指令

### 1. 无条件转移指令

#### (1) 段内直接转移指令 - JMP

**格式**：

* `JMP 标号`(标号指的是代码前的标号，如`START:`，而不是label)
* `JMP imm`

**功能**：程序无条件转移到段内由指令中给出的目标地址处（即改变IP为操作数）。

**操作**：`IP ← addr(偏移)`

**扩展：**

* `JMP`后加上`SHORT`、`NEAR`和`FAR`分别表示段内短转移、段内近转移和段间远转移。  
  `SHORT`表示IP改变为8位偏移量，范围为$-128\sim127$；  
  `NEAR`表示IP改变为16为偏移量，范围为$-32768\sim32766$（`SHORT`和`NEAR`实际不用在意，编译器会自动判断）；
  `FAR`表示CS和IP均要改变，需要压入段寄存器，进行进程、任务切换需要表明。

**举例**：

```asm
JMP 2010H       ; IP ← 2010H
JMP SHORT CODE1 ; IP ← (IP)+8位偏移量，转到标号为CODE1处执行指令
JMP NEAR NEXT   ; IP ← (IP)+16位偏移量，转到标号为NEXT处执行指令
```

### 2. 有条件转移指令

![图 6](images/3.2-Address%26Instruction-2--03-03_22-47-52.png)  
![图 7](images/3.2-Address%26Instruction-2--03-03_22-48-00.png)

### 3. 过程调用和返回

* `CALL 过程名`  
  * 过程：
    * `SP ← (SP) - 2`
    * `SS:SP ← (IP)`（`IP`入栈）
    * 变化`IP`
* `CALL FAR PTR 过程名`/`CALL DWORD PTR 存储单元地址`
  * 过程：
    * `SP ← (SP) - 2`
    * `SS:SP ← (CS)`（`CS`入栈）
    * `SP ← (SP) - 2`
    * `SS:SP ← (IP)`（`IP`入栈）
    * 赋值`IP`和`CS`
* `RET`（段内返回）
  * `IP ← (SS:SP)`（`IP`出栈）
  * `SP ← (SP) + 2`
* `RET`（段间返回）
  * 出栈两次
* `RET n`
  * 出栈一次/两次后，`SP ← (SP) + n`

## 六、处理器控制指令

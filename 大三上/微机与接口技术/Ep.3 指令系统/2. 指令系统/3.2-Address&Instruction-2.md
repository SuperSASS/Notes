# 第二节 8086的指令系统

包括六大类指令：

* 数据传送指令  
* 算术运算指令
* 逻辑运算和位运算指令
* 串操作指令
* 控制转移指令
* 处理器控制指令

对于存储器需注意的两点：

1. 存储器每个存储单元容量为1byte(8bit)
2. 存储器采用**小端方案**，即低字节在前（小地址），高字节在后（大地址）。  
   如对于16位数`24_5FH`，若存放首地址是`1000H`，则`(1000H)=5FH`、`(1001H)=24H`。

## 一、数据传送指令

将数据或地址传送到寄存器、存储单元或I/O口中。

**分类**：

* 通用数据传送指令
* 累加器专用传送指令
* 地址传送指令
* 标志传送指令
* 数据类型转换指令

**特点**：

* 除了`POPF`和`SHAF`，其他指令执行结果都**不影响标志位**。
* 如果列出两个操作数，执行过程：目标操作数←源操作数；如果列出一个操作数，另一个为隐含操作数

### 1. 通用数据传送指令

| 名称       | 指令          | 功能                           |
| ------------ | --------------- | -------------------------------- |
| 传送指令 | `MOV dest, src`  | `(src)`（一字或字节）传送到`dest` |
| 数据交换指令 | `XCHG dest, src` | `(src)`与`(dest)`互换          |
| 进栈指令 | `PUSH src`      | `src`入栈                      |
| 出栈指令 | `POP dest`       | 数据出栈，存入`dest`       |

#### (1) 传送指令 - MOV

**格式**：`MOV dest, src`

**功能**：将`src`的内容（一字或字节）传送到`dest`指定的reg或mem，`src`内容不变。

**约束**：

* 源操作数`src`：可以是imm(立即数)、reg(寄存器)或mem(内存中的操作数)。
* 目标操作数`dest`：可以是reg或mem（不允许为imm和**CS寄存器**）。
* IP和FR(FLAGS)不允许作为`dest`和`src`。
* imm不允许直接传到DS、ES或SS寄存器（传到这三个sreg，需要经过reg或mem中转）。
* `src`和`dest`**不允许同时**是mem或sreg。
* `src`和`dest`数据类型必须相同，同为byte或word。

**举例**：

```asm
; 合法
MOV AL, 5          ; byte, reg ← imm
MOV AX, BX         ; word, reg ← reg
MOV DS, AX         ; word, sreg ← reg

; 非法
MOV AX, BL         ; 数据类型不一致
MOV CS, AX         ; CS不能作为dest
MOV DS, 2010H      ; 立即数不能直接送到段寄存器
MOV [BX], [1000H]  ; src,dest不能都是mem
```

#### (2) 数据交换指令 - XCHG

**格式**：`XCHG dest, src`

**功能**：`src`的内容（一字或字节）与`dest`的内容（对应的一字或字节）互换。

**约束**：

* `dest`和`src`都可以是reg或mem，不可以是sreg、IP、imm。
* `dest`和`src`不可以同时是mem或AX(累加器)。

**举例**：

```asm
; 合法
XCHG BL, AH               ; byte, reg ← reg
XCHG AX, [BX][SI]         ; word, reg ← mem

; 非法
XCHG AX, 2010H            ; imm不能作为dest或src
XCHG CS, 5[SI]            ; sreg不能作为dest或src
XCHG [2010H], [2011H]     ; 不能同时是mem或AX
XCHG AX, AX               ; 不能同时是mem或AX
```

#### (3) (堆栈操作指令)进栈指令 - PUSH

堆栈段中，段地址由SS指示，栈顶偏移地址由SP(堆栈指针寄存器)指示。  
堆栈操作指令**数据类型只能是word**，且**imm不能作为操作数**。

堆栈的栈底是在大地址，栈顶是小地址，  
若`00000H`在上，则是下方向上方扩栈。

SP指向的当前地址(SP)和下一个地址(SP+1)为栈顶字16位数据。

---

**格式**：`PUSH src`

**功能**：`src`入栈。

**约束**：

* `src`可以是**sreg**、reg或mem。

**操作**：将指定的操作数压入堆栈，栈指针SP减2。  

1. `SP ← (SP)-2`
2. `SS:SP ← (src_low)`（如`src`是mem，则`src_low=(mem)`）
3. `SS:SP+1 ← (src_high)`（如`src`是mem，则`src_low=(mem+1)`）

**举例**：

```asm
; 合法
PUSH AX       ; word, reg入栈（SP-2后，reg_low传入SP；reg_high传入SP+1）
PUSH [2000H]  ; word, mem入栈（SP-2后，2000H传入SP；2001H传入SP+1）
PUSH CS       ; word, sreg入栈

; 非法
PUSH AL       ; 数据类型不能为byte（POP同）
PUSH 2000H    ; imm不能作为操作数（POP同）
```

![图 1](images/3.2-Address%26Instruction-2--10-14_13-11-11.png)

#### (4) (堆栈操作指令)出栈指令 - POP

**格式**：`POP dest`

**功能**：数据出栈，存入`dest`。

**约束**：

* `dest`可以是**sreg(除CS)**、reg(16bit)或mem。

**操作**：将指定的操作数压入堆栈，栈指针SP减2。  

1. `dest_low ← (SS:SP)`
2. `dest_high ← (SS:SP+1)`
3. `SP ← (SP)+2`

**举例**：

```asm
; 合法
POP SS       ; word, 出栈到sreg（(SP)传入SS_low；(SP+1)传入SS_high，SP+2）
POP [2000H]  ; word, 出栈到mem（(SP)传入2000H；(SP+1)传入2001H，SP+2）

; 非法
PUSH CS      ; CS不能作为dest
```

### 2. 累加器专用传送指令

| 名称   | 指令                                     | 功能                                           |
| -------- | ------------------------------------------ | ------------------------------------------------ |
| 换码指令 | `XLAT` / `XLAT addr`                       | 将内存表格（表格首地址为BX）中指定单元的值送至AL |
| 输入指令 | `IN AL(/AX), addr_IO` / `IN AL(/AX), DX`   | 从指定的I/O端口读入到AX(16bit)或AL(8bit) |
| 输出指令 | `OUT addr_IO, AL(/AX)` / `OUT DX, AL(/AX)` | 将AX(16bit)或AL(8bit)输出到指定的I/O端口 |

#### (1) 换码指令 - XLAT

**格式**：

* `XLAT`
* `XLAT addr`

**功能**：将内存表格中指定单元的指传送至AL。

**约束**：

* `src`和`dest`均隐含
* **BX**保存**内存表格首地址**，**AL**保存某**数据**在此表格中**偏移量**，  
  使用指令前，必须初始化BX和AL两个reg。
* 内存表格的数据类型**只能是byte**。
* 内存表格的最大容量是256byte（因为偏移量AL为8bit）。
* 格式2中的`addr`，**只是为了提高可读性**设置的，  
  执行操作时，**实际上是**先`BX ← (addr)`，再`XLAT`。

**操作**：`AL ← (BX+AL)`
  
**作用**：比如对于ASCII码表中的'a'，AL为97，使用指令后则能找到为'a'。

#### (2) (I/O指令)输入指令 - IN

I/O指令用于CPU和I/O端口之间进行数据传送。

---

**格式**：

* `IN AL, addr_IO`
* `IN AX, addr_IO`
* `IN AL, DX`
* `IN AX, DX`

**功能**：从指令中指定的I/O端口，读入一byte数据到AL（或一word数据到AX）。

**约束**：

* 采用格式1和格式2时，`addr_IO`的取值范围之`0 ~ FFH`，可以寻256个I/O端口。
* I/O端口地址值超过`FFH`时，只能采用格式3和格式4，  
  将地址保存到DX中，则寻址范围为`0 ~ FFFFH`，可以寻65536个I/O端口。
* 访问8bit的I/O端口时，`dest`选用AL；  
  访问16bit的I/O端口时，`dest`选用AX。

#### (2) (I/O指令)输出指令 - OUT

**格式**：

* `OUT addr_IO, AL`
* `OUT addr_IO, AX`
* `OUT DX, AL`
* `OUT DX, AX`

**功能**：将AL(AX)内容输出到一个8bit(16bit)的I/O端口。

**约束**：*同`IN`指令。*

### 3. 地址传送指令

汇编程序中，addr是一种特殊操作数，区别于一般数据操作数，其是16bit无符号数。  
为了突出addr的特点，故用专门的指令进行地址传送。

#### (1) 取偏移地址指令 - LEA

**格式**：`LEA reg_16, addr_mem`

**功能**：取变量、标号或表达式**所指的mem的偏移地址**（而非mem本身内容），送到16bit的寄存器reg_16中。

**约束**：

* `src`必须为存储器的**地址**。
* `dest`必须为**16位**的**通用寄存器**。

**操作**：`reg_16 ← EA(mem)`

**举例**：

```asm
LEA DI, [BX+SI]
```

设`(DS) = 2100H`、`(BX)+(SI) = 110H`、`(DS:110H) = 1234H`，  
执行后，`(DI) = (BX)+(SI) = 110H`。

#### (2) 地址指针装入DS指令 - LDS

**格式**：`LDS reg_16, mem_32`

**功能**：将内存中32位`src`中，低16bit（小地址）送到`reg_16`中，高16bit（大地址）送到**段寄存器DS**中。

**操作**：

1. `reg_16 ← mem_32_low`(`mem_32_low`即`(men_32)`)
2. `DS ← mem_32_high`（`mem_32_high`即`(mem_32+2)`）

**举例**：

```asm
LDS AX, [BX+SI]
```

设`(DS) = 2100H`、`(BX)+(SI) = 110H`、`(DS:110H) = 1234H`、`(DS:112H) = 9876H`，  
执行后，`(AX) = (DS:110H) = 1234H`、`(DI) = (DS:110H+2H) = 9876H`。

#### (3) 地址指针装入ES指令 - LES

**格式**：`LES reg_16, mem_32`

*只是将`LDS`中的DS改为ES，其余相同。*

### 4. 标志传送指令

#### (1) 取标志指令 - LAHF

**格式**：`LAHF`

**功能**：

**约束**：

**操作**：

**举例**：

#### (2) 置标志指令 - SAHF

**格式**：`SAHF`

**功能**：

**约束**：

**操作**：将AH的内容写入标志寄存器0~7位。

**举例**：

#### (3) 标志入栈指令 - PUSHF

**格式**：`PUSHF`

**功能**：

**约束**：

**操作**：

**举例**：

#### (4) 标志出栈指令 - POPF

**格式**：`POPF`

**功能**：

**约束**：

**操作**：

**举例**：

### 5. 数据类型转换指令

#### (1) 字节转换为字指令 - CBW

**格式**：`CBW`

**功能**：

**约束**：

**操作**：

**举例**：

#### (2) 字转双字指令 - CWD

**格式**：`CWD`

**功能**：

**约束**：

**操作**：把寄存器**AX**中数据的符号位扩展到**DX**寄存器中。

**举例**：

## 二、算数运算指令

就是用来执行算术运算。

**分类：**

* 加法指令
* 减法指令
* 乘法指令
* 除法指令
* 十进制调整指令

**特点：**

* 大多数对标志位产生影响。
* 操作数有一个或两个。
* 必须**有一个操作数在寄存器**中（双操作数允许源操作数是立即数，单操作数只允许为寄存器）。

### 1. 加法指令

* `ADD` - 加法指令
  * 格式：

    ```asm
    ADD dest, src
    ; e.g.
    ; ADD CX, DI
    ; ADD [BP], CL
    ; ADD CL, TEMP
    ; ADD BYTE PTR [DI], 3
    ```
  
  * 
* `ADC` - 带进位位的加法指令  
  使用前要将CF清零。  
  如果两操作数位数不一样，要进行符号扩展。
* `INC` - 加1指令  
  不影响CF进位标志位。

### 2. 减法指令

#### (1) 不带借位减法指令 - SUB

  位数不同，符号扩展

#### (2) 带借位减法指令 - SBB

* `SBB` - 带借位的减法  
  先将CF清零。

#### (3) 减1指令 - DEC

* `DEC` - 减1指令。
  不影响CF进位标志位。

#### (4) 比较指令 - CMP

**格式**：`CMP dest, src`

**功能**：

左侧(dest)减右侧(src)，结果只保存在标志寄存器中，不返回。  
主要用于搭配**各种转移指令**。

**约束**：

* 源操作数`src`：可以是imm(立即数)、reg(寄存器)或mem(内存中的操作数)。
* 目标操作数`dest`：可以是reg或mem。
* 对于无符号数相减：影响ZF（判零）和CF（进位）
* 对于有符号数相减：影响SF（符号）、ZF（判零）和OF（溢出）  
  不溢出时(OF=0)，若SF=0（结果为正），则$dest>src$；  
  溢出时(OF=1)，若SF=1（结果为负），则$dest>src$。

**举例**：

```asm
CMP AL, 0   ; AL - 0
```

#### (5) 求补指令 - NEG

* `NEG`

### 3. 乘法指令

* `MUL` - 无符号数的乘法  
  对于8位  
  对于16位

### 4. 除法指令

### 5. 十进制调整指令

## 三、逻辑运算和位运算指令

### 1. 逻辑运算指令

#### (3) 逻辑测试指令 - TEST（不返回与）

**格式**：`TEST dest, src`

**功能**：

将dest与src相与，但只影响标志位，不返回结果。  
对标志位影响：CF、OF清0；根据结果影响SF、ZF、PF；AF值不定。

**操作**：`(dest) ^ (src)`

## 四、串操作指令

## 五、控制转移指令

8086中程序(Code)的执行，是由代码寄存器CS和指令指针寄存器IP共同决定，  
计算方法：$CS \times 10H + IP$。

一般来说是按顺序执行，  
但通过控制转移指令，可以改变CS和IP，从而改变执行顺序。

可以分为“段内转移指令”和“段间转移指令”，  
段内转移指令，指程序在同一代码段内，只有IP改变；  
段间转移指令，指程序将转移到其它段，CS和IP均改变。

**分类**：

* 无条件转移指令
* 条件转移指令
* 循环控制指令
* 过程调用与返回指令
* 中断指令

### 1. 无条件转移指令

#### (1) 段内直接转移指令 - JMP

**格式**：

* `JMP 标号`(标号指的是代码前的标号，如`START:`，而不是label)
* `JMP imm`

**功能**：程序无条件转移到段内由指令中给出的目标地址处（即改变IP为操作数）。

**操作**：`IP ← addr(偏移)`

**扩展：**

* `JMP`后加上`SHORT`、`NEAR`和`FAR`分别表示段内短转移、段内近转移和段间远转移。  
  `SHORT`表示IP改变为8位偏移量，范围为$-128\sim127$；  
  `NEAR`表示IP改变为16为偏移量，范围为$-32768\sim32766$（`SHORT`和`NEAR`实际不用在意，编译器会自动判断）；
  `FAR`表示CS和IP均要改变，需要压入段寄存器，进行进程、任务切换需要表明。

**举例**：

```asm
JMP 2010H       ; IP ← 2010H
JMP SHORT CODE1 ; IP ← (IP)+8位偏移量，转到标号为CODE1处执行指令
JMP NEAR NEXT   ; IP ← (IP)+16位偏移量，转到标号为NEXT处执行指令
```

## 六、处理器控制指令
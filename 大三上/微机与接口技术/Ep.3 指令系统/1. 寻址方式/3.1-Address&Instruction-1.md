# 第一节 寻址方式

## 一、寻址技术

七种寻址方式：

* 立即寻址
* 寄存器寻址
* 直接寻址
* 寄存器间接寻址
* 寄存器相对寻址
* 基址变址寻址
* 相对基址变址寻址

前两者直接给出操作数，后面的均给出地址。

对于一个多操作数指令，**不同的操作数**可能采用**不同的寻址方式**。

以下均以`MOV Des, Res`指令为例讲解寻址方式。
需要保证源操作数与目的操作数**位数一致**，否则无法存放（如不能将AX存放到BL中）。

### 1. 立即寻址

操作数**直接出现在指令**中。  
此时操作数直接存放在跟指令一起的**代码段**中，紧跟在操作码后面。

```asm
MOV AL, 1AH;   % 1AH→AL
MOV AX, 2010H; % 2010H→AX
```

对于2字节数据`2010H`，其在操作码后先存放`10H`、再存放`20H`。

**约束**：

* 对于段寄存器如`DS`，约定不能直接赋值，需要用寄存器如`AX`中转。  
  `CS`不允许赋值。
* 如果用十六进制，数以字母开头，需要在前面加`0`。
* 立即数可以是含`+ - * / ( )`的运算表达式

### 2. 寄存器寻址

操作数在指令**指定的寄存器**中。  

优点：

* 操作数在 CPU 内部的寄存器中，指令执行不需要访存**速度快**
* 寄存器号短（一共14个寄存器，就$0~14$），指令机器码**长度短**。

可以出现的寄存器：

* 16位数据：AX/BX/CX/DX、SI/DI/SP/BP、CS/DS/SS/ES
* 8位数据：AH/AL、BH/BL、CH/CL、DH/DL

**约束**：

* 两个操作数不能同时是段寄存器(`CS/DS/SS/ES`)
* 目标操作数不能是代码段寄存器(`CS`)（因为里面存放的要执行的指令，不能随意改写）

### 3. 直接寻址

操作数在**存储器（内存）**中。
指令给出的是操作数在内存的**偏移地址**（有效）$EA$。

为了与立即寻址区别，该有效地址必须用`[]`括起（即**看到`[]`就代表偏移地址**）。

除了用数字加方括号的形式`[xxxxH]`，也可以以用用户自定义符号表示`LABLE`，  
如：`MOV AL, LABLE`。  
若符号带有运算，也算直接寻址。（如举例第四个）x`

需要注意：没有特殊说明，直接寻址的操作数一般**在内存的数据段**中，即**隐含的段寄存器是DS**。  
即需要将有效地址加上段寄存器，得到物理地址。
*对于机组中学的，应该也是隐含在数据段的（因为不可能取其他段的数据，如自检程序）。*

```asm
MOV AX, [2020H];  % (DS:2020H)→AL, (DS:2020H+1)→AH
MOV BH, ES:[10H]; % (ES:10H)→BH
MOV AL, LABLE;    % (DS:LABLE)→AL
MOV AL, LABLE+5;  % (DS:LABLE+5)→AL
```

### 4. 寄存器间接寻址

操作数的有效地址EA存放在寄存器中。  
寄存器名用`[]`括起。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

```asm
MOV AX, [BX];    % (DS:EA)→AL, (DS:EA+1)→AH，其中EA=(BX)
MOV AL, ES:[BX]; % (ES:EA)→AL，其中EA=(BX)
MOV AX, [BP];    % (SS:EA)→AL, (SS:EA+1)→AH，其中EA=(BP)
```

### 5. 寄存器相对寻址

*看到相对，即加了数字的偏移量。*

操作数的有效地址EA是：指令中**指定的基址或变址寄存器**的值，与**位移量**之和。

可用寄存器只有4个：

* BX、SI、DI - 在数据段（`DS:EA`）
* BP - 在堆栈段（`SS:EA`）

偏移量：**有符号数**，可以为8位或16位。

位移量三种等效表示方式：

* `MOV AX, 8[BX]`
* `MOV AX, [BX]+8`
* `MOV AX, [BX+8]`

```asm
MOV AX, 8[BX]; % (DS:EA+8)→AL, (DS:EA+8+1)→AH, 其中EA=(BX)
```

### 6. 基址变址寻址

操作数的有效地址EA是：指令中指定的**基址寄存器**的值，与**变址寄存器**的值之和。  

可用基址寄存器只有2个：

* BX - 数据在数据段`DS`
* BP - 数据在堆栈段`SS`

可用变址寄存器只有2个：

* SI - 源变址寄存器
* DI - 目的变址寄存器

格式：`[基址寄存器][变址寄存器]`

计算：段基址*10 + 基址寄存器值 + 变址寄存器值

```asm
MOV AX, [BX][SI]
```

### 7. 相对基址变址寻址

就是基址变址基础上，再加上个偏移量

```asm
MOV AX, 3[BX][SI]
```

## 二、拓展

任何处理器都主要确定两个问题：

* 数据在哪里
* 处理数据长度

用reg代表寄存器，sreg代表段寄存器。

对于8086：

* reg: AX, BX, CX, DX, SP, BP, SI, DI
* sreg: SS, CS, DS, ES

对于`[]`这种偏移地址，**只能用**bx、si、di、bp，  
且组合方式为：[(bx/bp)(si/di)]

对于处理数据长度，可以直接在指令中给出（指根据寄存器的长度来定）。  
比如`mov AX, ...`，其中`AX`就说明了操作的为字（16位）。

也可以直接指明，如用`word ptr`/`byte ptr`，表示访问的内存单元是1字。  
比如`inc word ptr AX`。  
对于没有寄存器参与的内存单元访问指令中，直接指明尤其必要。

还有些指令默认了数据长度，  
如`push`,`pop`，其只进行字操作。

# 有关 Viewport 的临时总结

~~在Mode中，初始的Viewport布局，与`hangingProtocol`和`viewports`属性共同决定。~~

暂时记录：  
感觉跟Mode里的`viewports`属性并不大，  
主要是根据`hangingProtocol`决定的【因为本身Hanging Protocol中就规定了viewport】。  
而Mode里的`viewports`，我感觉主要是提供与SOP Class Handler的绑定。

Mode里定义的`viewports`，第一是告诉该Mode支持的viewport类型。  
如下面的情况：  
![图 2](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-29_04-16-36.png)  
当`hangingProtocol`为mpr时，但`viewports`定义的是明显不符的PDF的，  
则加载的时候会弹窗报错如下：  
![图 3](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-29_04-17-32.png)  
再设断点(platform/viewer/src/component/ViewportGrid.tsx)，可看到如下情况：  
![图 4](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-29_04-23-57.png)

那么情况就大致清晰了一下：

* `viewports`：定义该Mode**支持的viewport**，以及其**对应的SOP Handler**，故一般照抄（不包含任何Viewport本身的定义、实现）
* `hangingPotocol`：定义了**初始页面显示的Viewport**，以及各个Viewport的属性
* `displaySet`：没什么好说的，就是转换成OHIF后的（非）**影像显示集**
* `sopClassHandlers`：~~虽然是把displaySet放到hangingPotocol定义的viewport上~~  
  感觉理解有误，这个是把DICOM元数据(Metadata)(或说DICOM SOP Class)转换为DisplaySet的（就是在左侧可以展示的东西）  
  对于每个instance看到的元数据见下图：  
  ![图 6](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-31_04-01-45.png)  
  转换为displaySet（见下图）  
  ![图 7](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-31_04-02-09.png)  
  还可以看见上面有个`SOPClassHandlerId`属性，就代表这个DICOM元数据是由哪个Handler翻译解释的。

  存在有点不清楚的点：
  ![图 5](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-29_04-28-02.png)  
  这是Mode只定义了一个SOP Handler，所以图上只有一个；  
  **问题**：但如果定多个，某一具体的DisplaySet该怎么选择SOP Handler？

补充一个Debug可以看的：  
platform/viewer/src/component/ViewportGrid.tsx  
其中的`getViewportPanes()`就是在图片拖进（双击）到viewport时，获得各个viewport的对应图像的函数，可在317行打个断点。

## 挂片协议

挂片协议服务中，`protocols`保存了目前所有插件提供的协议：
![图 1](images/5.Viewport%2BHangingProtocol%2BDisplaySet--03-29_04-01-21.png)

需要明确挂片协议干嘛的：

* 每一切片的加载策略
* 规定Viewport的若干种状态
  * 布局
  * 每一个Viewport
    * Id、Type、方向、toolGroupId、SyncGroups

## 需要知道渲染流程

### OHIFCornerstoneViewport

使用的Viewport，应该都是这个。
`extensions\cornerstone\src\Viewport\OHIFCornerstoneViewport.tsx`

Viewport的类型：  
![图 1](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-07_05-02-25.png)  
[ViewportType](https://www.cornerstonejs.org/api/core/namespace/enums/#ORTHOGRAPHIC)

### 流程

![图 2](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-07_05-07-28.png)  

对于`extensions\cornerstone\src\init.tsx`里订阅的`CUSTOM_IMAGE_LOAD_PERFORMED`的触发流程：  
在`runImageLoadStrategy()`\[HangingProtocolService.ts] ← `_setVolumeViewport()`\[CornerStoneViewportService.ts] ← `_setDisplaySets()`\[.] ← `setViewportData()`\[.] ← `loadViewportData()`\[OHIFCornerstoneViewport.tsx]

补充：

* `viewportData.datas`来源于定义挂片协议时的每个Viewport的`displaySets`  
  而`lutPresentation`则来源于`displaySet`里的`options`  
  ![图 3](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-07_05-22-11.png)  
  ![图 4](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-07_05-22-43.png)

## 有关3D - MIP

![图 5](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-07_05-29-40.png)  
对应Cornerstone的MAXIMUM_INTENSITY_BLEND

### 究极的 - 进入Mode后 - 从加载影像到挂片到Viewport的流程

![图 6](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-10_01-38-22.png)

1. 首先从DICOM Web服务器读取该Study的所有的Series
2. 加载完成后，对displaySet服务调用`makeDisplaySets`函数  
   在内部的效果：对于每一个Series，根据Mode里的`sopClassHandlers`，找有没有满足能解析的SOPClassHandler，把其从Metadata转换为DisplaySet。  
   ![图 7](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-10_01-43-23.png)  
3. 调用`hangingProtocolService`的`run()`【假设只存在一个HP，跳过排名步骤，故HPId就是它】  
   虽然不清除流程，但就是根据什么方法，最终安排该DisplaySet，到Mode中的能解释该DisplaySet的`viewports`中。  
   所以虽然HP里定义了Viewport的最外层框架，但最终落实的Viewport不一样，可能造成属性不为预期（典型的就是ToolGroup）。
   e.g. 对于SEG类型的Viewport，其内部会额外带一层SEGViewport，其`ToolGroupId`为`SEGToolGroup-0`这样。
   * 同时，对于displaySet👉Viewport，是按Viewport的顺序，查找可展示该displaySet的Viewport，代码如下：  
     ![图 8](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-10_12-03-47.png)  

## 加载影片流程

会发现：到全框架加载好后，影片是慢慢加载出来的。  
还记得原来HangingProtocol中设置的加载策略吗，就是这里的原因。

在Viewport那些都设置好后，此是，渲染的关键数据`pixelData`还并未读取，所以看到的是一片空白，  
之后，会调用"HangingProtocolService"的`runImageLoadStrategy`，根据前面选择的策略，逐步加载像素数据pixelData。

然后，运行策略后，异步加载（所以那个事件`CUSTOM_IMAGE_LOAD_PERFORMED`只是代表加载正在进行），  
假如是`interleaveTopToBottom`策略：

会在来自"@cornerstonejs/core"的`imageLoadPoolManager`管理池中加入读取每一个切片(Instance)的请求(Request)（可见大约115行）  
![图 9](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-11_15-28-10.png)  
可看注释。

![图 10](images/5.Viewport%2BHangingProtocol%2BDisplaySet%2BSOPClassHandler--04-11_15-29-27.png)  

其中：

* `handleArrayBufferLoad` - 主要是把影像数据(PixelData, scalarData, ArrayBuffer)加载进去
# Ep.9 查找

## 0x01 定义

查找的对象是“查找表”（映射）。  
是一种松散的数据结构：集合。

* 关键字：数据元素中某个数据项或者组合项的值，用它可以标示一个数据元素。
  * 主关键字：唯一的标识一个数据元素的值。
  * 次关键字：只能标识部分数据元素。

四个基本操作：

1. 查询某个“特定的”数据元素是否在查找表中
2. 检索某个“特定的”数据元素的各种属性
3. 在查找标中插入一个数据元素
4. 在查找标中删除某个元素

分为两种查找标：

* 静态查找表：不涉及插入和删除操作的查找表。查找过程中结构始终不发生变化。  
  数据结构为线性表。
* 动态查找表：结构在查找过程中可能会发生变化。  
  数据结构为树。

---

类型定义：

```c++
typedef int KeyType; //关键字（键值）类型

typedef struct{
  KeyType key;
}ELemType; //元素类型
```

## 0x02 静态查找表（顺序表）

```c++
typedef struct{
  int size;
  ELemType Table;
}SSTable;
```

1. 遍历查找：  
   不需要排序，从头到尾全部遍历，$O(n)$
2. 二分查找：  
   需要有序，$O(\log n)$。  
   若为无序，则要排序，为$O(n\log n)$
   * 二叉判定树：描述二分查找这个过程的二叉树，结点记录找到了那个结点`mid`
3. 分块查找：  
   为遍历查找和二分查找的综合，块间用二分（也可顺序），块内用遍历。  
   故块内无序，块间**分块有序**（第$i$块最小关键字大于第$i-1$块最大关键字）

   建立索引表，记录每一块最大（或最小）关键字，以及块的起始位置。
   * 最佳分块长度：$\sqrt(n)$

## 0x03 动态查找表

### 1. 二叉排序树

> 定义：
>
> * 若左子树不空，则**左子树**上所有结点的值都**小于**根结点的值。
> * 若右子树不空，则**右子树**上所有结点的值都**大于**根结点的值。

基本操作：

1. 查找  
   *就普通的二分查找，很简单。*
2. 插入
   在查找中额外返回插入结点的位置，为查找过程中找到的空结点的父节点。
3. 删除  
   令$p$为$f$的孩子：  
   * $p$没有左右子树或只有一边：删除后将有的子树连到$f$的对应位置。
   * $p$两个子树都有：需要合并左右子树  
     1. 将左子树连到右子树最左侧，或者将右子树连到左子树最右侧。  
        会导致深度变大，故不采用。
     2. 找左子树的最右侧（最大值）替换$p$，若最大值有左子树（不可能有右子树），需要把左子树连到最大值的父节点。  
        **能减小深度，故使用这个方法。**

由于二叉排序树效率与树的形态有关，所以要采用某种“能保持平衡”的平衡二叉树。

### 2. 平衡二叉树(AVL树)

保证左右子树深度的绝对值不超过$1$，  
关键操作：**旋转**(rotate)。

* 平衡因子$BF$：左子树深度$-$右子树深度，在AVL树中其值只能是$-1,0,1$。

需要在插入的时候根据平衡因子保持平衡。  
在插入的时候，若$BF=0$则不会导致失衡，只有$\pm1$才可能失衡。

步骤：

1. 在查找$s$结点插入位置的过程中，找到离$s$最近且$BF\ne0$的上结点$a$。  
   若全平衡，$a$为根结点。
2. 插入后，修改$a$到$s$上所有结点的$BF$。
3. 判断以$a$为根的子树是否失衡，若失衡则根据失衡类型调整。
# Ep.9 查找

## 0x01 定义

查找的对象是“查找表”（映射）。  
是一种松散的数据结构：集合。

* 关键字：数据元素中某个数据项或者组合项的值，用它可以标示一个数据元素。
  * 主关键字：唯一的标识一个数据元素的值。
  * 次关键字：只能标识部分数据元素。

四个基本操作：

1. 查询某个“特定的”数据元素是否在查找表中
2. 检索某个“特定的”数据元素的各种属性
3. 在查找标中插入一个数据元素
4. 在查找标中删除某个元素

分为两种查找标：

* 静态查找表：不涉及插入和删除操作的查找表。查找过程中结构始终不发生变化。  
  数据结构为线性表。
* 动态查找表：结构在查找过程中可能会发生变化。  
  数据结构为树。

---

类型定义：

```c++
typedef int KeyType; //关键字（键值）类型

typedef struct{
  KeyType key;
}ELemType; //元素类型
```

## 0x02 静态查找表（顺序表）

```c++
typedef struct{
  int size;
  ELemType Table;
}SSTable;
```

1. 遍历查找：  
   不需要排序，从头到尾全部遍历，$O(n)$
2. 二分查找：  
   需要有序，$O(\log n)$。  
   若为无序，则要排序，为$O(n\log n)$
   * 二叉判定树：描述二分查找这个过程的二叉树，结点记录找到了那个结点`mid`
3. 分块查找：  
   为遍历查找和二分查找的综合，块间用二分（也可顺序），块内用遍历。  
   故块内无序，块间**分块有序**（第$i$块最小关键字大于第$i-1$块最大关键字）

   建立索引表，记录每一块最大（或最小）关键字，以及块的起始位置。
   * 最佳分块长度：$\sqrt n$

## 0x03 动态查找表

### 1. 二叉排序树

> 定义：
>
> * 若左子树不空，则**左子树**上所有结点的值都**小于**根结点的值。
> * 若右子树不空，则**右子树**上所有结点的值都**大于**根结点的值。

基本操作：

1. 查找  
   *就普通的二分查找，很简单。*
2. 插入
   在查找中额外返回插入结点的位置，为查找过程中找到的空结点的父节点。
3. 删除  
   令$p$为$f$的孩子：  
   * $p$没有左右子树或只有一边：删除后将有的子树连到$f$的对应位置。
   * $p$两个子树都有：需要合并左右子树  
     1. 将左子树连到右子树最左侧，或者将右子树连到左子树最右侧。  
        会导致深度变大，故不采用。
     2. 找左子树的最右侧（最大值）替换$p$，若最大值有左子树（不可能有右子树），需要把左子树连到最大值的父节点。  
        **能减小深度，故使用这个方法。**

由于二叉排序树效率与树的形态有关，所以要采用某种“能保持平衡”的平衡二叉树。

### 2. 平衡二叉树(AVL树)

保证左右子树深度的绝对值不超过$1$，  
关键操作：**旋转**(rotate)。

* 平衡因子$BF$：左子树深度$-$右子树深度，在AVL树中其值只能是$-1,0,1$。

需要在插入的时候根据平衡因子保持平衡。  
在插入的时候，若$BF=0$则不会导致失衡，只有$\pm1$才可能失衡。

步骤：

1. 在查找$s$结点插入位置的过程中，找到**离$s$最近**且$BF\ne0$的上结点$a$。  
   若全平衡，$a$为根结点。
2. 插入后，修改$a$到$s$上所有结点的$BF$。  
   插入的在左子树则$BF-1$，在右子树则$BF+1$。
3. 判断以$a$为根的子树是否失衡，若失衡则根据失衡类型调整。

有四种失衡类型：

1. LL型 - 在A的左子树（其根结点为B）的左子树插入一个结点，$BF=2$  
   顺时针旋转  
   ![LL型](images/Search--12-09_10-17-55.png)
2. RR型 - 在A的右子树（其根结点为B）的右子树插入一个结点，$BF=-2$  
   逆时针旋转
3. LR型 - 在A的左子树的右子树（其根结点为C）插入一个结点，$BF=-2$  
   先对C逆时针旋转（RR型），再顺时针旋转（LL型）。  
   ![LR型](images/Search--12-09_10-36-33.png)

   > 不采用LL型同样的方式进行调整的原因：  
   > 可能仍会导致新的根结点$B$失衡。
4. RL型 - 在A的右子树的左子树（其根结点为C）插入一个结点，$BF=2$  
   先对C顺时针旋转（LL型），再逆时针旋转（RR型）。

### 3. B-树

也叫多路平衡查找树。  
每个结点类似于分块有序组织，即**类似于分块查找**。

子树满足以下要求：

* 树中每个结点至多有$m$个子树。
* 若根结点不是叶子节点，则至少要有两棵子树。
* 除根结点之外的非叶子节点，至少要有$\lceil\frac{m}{2}\rceil-1$

关键字满足以下要求：

* 对于每一个结点，若划分成$N$个区块，则要有$N-1$个关键字
* $N-1$个关键字划分为$N$个区块，其中每个区块都**大于左边的关键字，小于右侧的关键字**。
* 关键字个数满足：$\lceil\frac{m}{2}\rceil-1 <cnt <m-1$

「图」

---

性质：

* $m$阶B-树包含$N$个关键字，叶子节点数为$N+1$个。

---

插入操作：  
直接插入到最后一阶的关键字中。  
若插入后超过$m-1$个，则要“分裂”。

分裂操作：  
将前半部分作为新的结点；后半部分也作为新的结点，  
再将最中央的关键字上移到父节点关键字中。  
*若父节点为根结点，则生成新的根结点。*

---

![分裂操作](images/Search--12-09_11-23-43.png)  

删除操作：
对于非最后一阶的删除，找一个最后一阶的结点代替。
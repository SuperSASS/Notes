# 第十章 排序

## 定义

### 数据存储形式

1. 线性表
2. 静态链表
3. 分为两组，存储数据和存储顺序

### 性能指标

1. 时间复杂度：比较/交换的次数。
2. 空间复杂度：排序时需不需要额外空间。
3. 稳定性：对于相同元素，其相对顺序是否改变。如果改变则稳定性差；否则好。

## 一、插入排序

### 1. 插入排序

将原始数据按顺序依次插入到一个新的数组中。

插入时可将待插元素放到$a[0]$位置，与$a[i]$比较，  
如果不满足则将$a[i]$后移，直到满足$a[i]=a[0]$。

时间复杂度：

* 最优复杂度：$O(n)$
* 最差复杂度：$O(n^2)$
* 平均复杂度：$O(n^2)$

空间复杂度：$S(1)$

### 2. 折半插入排序

在查找插入位置的时候采用二分查找。

### 3. 希尔排序

思想：分段进行插入排序。

但这里分段的时候**不是简单的直接分段**，因为局部有序并不能使得插入排序节约时间（并不是整体有序）。

而是选取一个增量$d$，按每$d$个一组分组，然后开始排序，  
这样小的数据就会向前移动；  
再减少$d$，继续分组插入排序，  
一直重复，直到$d\to1$（所有数据一组，整体排序）

$d$的序列：$d_{k+1}={d_k}\div2 \qquad d_1=n\div2$

* 时间复杂度：$O(n^\frac{3}{2})$

## 二、交换排序

* 冒泡排序
* 快速排序

### 1. 冒泡排序

特点，两两交换。

```c++
bool exchange=false;
for (ALL)
{
    if (a[i]>a[i+1]) swap(),exchange=1;
    if !(exchange) return;
}
```

* 时间复杂度：$O(n^2)$
* 空间复杂度：$S(1)$
* 稳定算法

改进：

1. 双向冒泡排序  
   冒泡算法对于值大的大气泡，能一次冒泡至最顶部；  
   但对于值小的小气泡，只能一次向下沉一个位置。  
   故可以在排序过程中**交替改变扫描方向**。

### 2. 快速排序

本质是对数据进行**分区交换（冒泡）排序**。

* 不稳定

## 三、选择排序

### 1. 选择排序

与冒泡排序区别：  
冒泡是两两比较交换，  
选择是依次选出最大值放在第一个、次大值放在第二个……

* 时间复杂度：$O(n^2)$
* 空间复杂度：$S(1)$
* **不稳定**算法  
  因为选择的时候可能就把后面的元素选到前面去了。

### 2. 堆排序

利用比赛的思想进行的排序，  
两两比较，择出较大的。

先构建一种数据结构，储存这种两两比较的结果

* 小根堆：根节点$<$左右结点
* 大根堆：根节点$>$左右结点

注意虽然叫“堆”，但**实际上是树**，  
但因为操作的时候只取根节点，近似于堆的操作。  
并且与二叉排序树不同，只是小于或大于左右结点即可。

---

每次从堆中取出堆顶元素，对剩余的元素在重构建堆，  
重复操作，完成排序。

1. 建堆（小根堆）：  
   先初始化将整个序列作为一个二叉树，  
   接下来从最后一个非叶子节点（最下面最右边）开始，与其两边的孩子比较。  
   如果大于任意一个叶子节点，选择一个最小的交换。并**继续向下比较**，直到到叶子节点。  
   然后**自底向上**依次进行上述操作，完成建堆。

   ⭐**注意一定是自底向上。**
   > 自顶向下不行的原因：
   >
   > 从顶向下，只能保证从顶到$i$结点这层，满足上一层均大于下一层。  
   > 当回溯交换结点下来时，对于$i$这一层与下一层这个交界处，不能保证换下来的比下一层大（满足条件）
2. 重构堆：  
   输出后，直接将最后一个结点放到根，并只用对根节点进行比较操作。

* 时间复杂度：$O(n\log n)$
* 空间复杂度：$S(1)$
* 不稳定

## 四、归并排序

* 时间复杂度：$O(n \log n)$
  * 归并：$O(n)$
  * 需要$\log n$趟
* 空间复杂度$S(n)$（如果用递归还要额外开销）
* 稳定

## 五、基数排序

借助多关键字进行排序。

1. 最高位优先排序(MSD)  
   对关键字组$(K_0,K_1,\cdots,K_n)$，从$K_0$开始先排序，  
   对于$K_0$相同的数据，按照$K_1$进行排序，  
   之后依次类推，直到对于一个关键字$K_i$没有进行排序
2. 最低位优先排序(LSD)  
   即从$K_n$开始排序。

两者区别：

* MSD需要对序列排序后划分  
* LSD则不用划分，直接整体进行每一位的关键字比较。可以利用链表进行。

* 时间复杂度：$O(n+rd)$

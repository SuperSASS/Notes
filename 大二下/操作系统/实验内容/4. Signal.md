# Signal - 信号

Linux中的信号(signal)，是用来进程间通信的工具。  
信号是一个发送到某个进程或同一进程中的**特定线程的异步通知**，用于**通知**发生的一个**事件**。  
在信号到达时，程序会**中断目前的操作**去进行该信号的**相应处理**。  
因此跟“中断”(interrupt)机制有点类似，可以用来**模拟软中断**。

# 过程

## 0. 注册（安装）信号处理函数

* `signal()`
* `sigaction()`

### 1. signal()

### 2. sigaction()

**函数定义：**

```c
int sigaction(
    int signum,
    const struct sigaction *act,
    struct sigaction *oldact);
```

**`sigaction`类型：**

```c
struct sigaction
{
    union
    {
        __sighandler_t _sa_handler;
        void (*_sa_sigaction)(int, struct siginfo *, void *);
    } _u;
    sigset_t sa_mask;
    unsigned long sa_flags;
}
```

* `sa_handler` - 跟`signal()`里的一样，就是个入口函数，  
  需要一个`int`存放信号类型(Signal number)，则类型可以看作`void *...(int)`。
* `sa_sigaction` - 含有额外信息的入口函数
  * 第一个参数`int` - 跟handler的一样，存放Signal number
  * 第二个参数`siginfo*`：

    ```c
    siginfo_t
    {
        int si_signo; // 信号值Signal number，即SIG***，对所有信号都有意义（都要使用）
        int si_errno; // errno值，对所有信号都有意义【注意：Linux中一般不使用，值恒为0
        int si_code;  // 信号产生的原因，对所有信号有意义
    
        /* 以下为联合数据结构，不同信号拥有不同成员（不同信息） */
        union
        {
            int _pad[SI_PAD_SIZE]; // 确保分配足够大的存储空间
    
            struct // 对SIGKILL有意义的结构
            {
                ...
            }...;
            struct // 对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构
            {
                ...
            }...;
            // 一般来说用不到这里的信息，有需要再自行查阅文档。
        }
    }
    ```

    详细见[文档](https://man7.org/linux/man-pages/man2/sigaction.2.html)。
    > 对于`SIGCHIL`信号（子进程返回信号）的`si_code`和`si_status`说明：
    >
    > 一般用这个带额外信息的信号，就是用来看子进程是怎么退出的，  
    > 所以这里额外讲一下这个方面：
    >
    > 1. `CLD_EXITED` - 子进程正常退出
    > 2. `CLD_KILLED` - 子进程被杀死
    > 3. `CLD_DUMPED` - 子进程异常退出
    > 4. `CLD_TRAPPED` - 子进程触发陷阱
    > 5. `CLD_STOPPED` - 子进程被暂停
    > 6. `CLD_CONTINUED` - 子进程恢复运行
    >
    > 以上都是宏编号，判断的时候直接等于上面的宏就行。
    >
    > 其他`si_code`可以搜索文档的“For a regular signal”后面的部分。
    >
    > ---
    >
    > 而如果`si_code`为`CLD_DUMPED`，则可以额外查看联合数据结构中的`si_status`成员，  
    > 其代表了**子进程返回的Signal number**。  
    > 如子进程因除以0而异常退出，则`si_status = 8`，代表`SIGFPE`。
    >
    >> 验证如下：  
    >> ![子进程设计](images/4.%20Signal--05-21_10-22-20.png) ![父进程设计](images/4.%20Signal--05-21_10-24-07.png)  
    >> 让子进程在6s的时候分别造成不同类型的异常退出（浮点数错误、段错误、调用`abord()`）,  
    >> 可以观察到父进程得到的`si_status`分别为：
    >> ![浮点数错误时的si_status](images/4.%20Signal--05-21_10-23-22.png)  
    >> ![段错误时的si_status](images/4.%20Signal--05-21_10-25-20.png)  
    >> ![调用abort()时的si_status](images/4.%20Signal--05-21_10-26-07.png)  
    >> 可以看到分别对应`SIGFPE`、`SIGSEGV`、`SIGABRT`。
  * 第三个参数`void *` - 一般没有用，直接传给无用变量`ucontext`即可。

示例：

```c
void func_childExit(int sig_ID siginfo_t *info, void *ucontext)
{
    printf("➤ Received the signal named \"SIGCHLD\"(ID:%3d), which means the child process has terminated.", sig_ID);
}
int main()
{
    /* 初始化sigaction */
    struct sigaction action;
    action.sa_sigaction = func_childExit;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    sigaction(SIGCHLD, &action, NULL); // 子进程结束、被中断或是在被中断之后重新恢复的信号
}
```

## 1. 产生并接收信号

![所有信号](images/4.%20Signal--05-21_03-03-25.png)

### 常见信号类型

信号类型(Signal number)：

* 暂停类信号
  * `SIGSTOP` - 暂停进程信号。
    **不能被忽略、处理和阻塞！**
* 终止类信号
  * `SIGINT` - 由用户在终端中输入“INTR字符”产生的信号（一般都是Ctrl+C(^C)产生）  
    通知前台进程组正常终止进程，不会产生core dump文件。
  * `SIGQUIT` - 由用户在终端中输入“QUIT字符”产生的信号（一般都是Ctrl+\\(^\\)产生）  
    通知前台进程组终止进程，并产生core dump文件。因此可以看作是一种程序异常退出信号。
  * `SIGTERM` - 要求进程正常结束(terminate)信号  
    与`SIGKILL`最大不同是可以被忽略、处理和阻塞，跟`SIGINT`类似。  
    终端中`kill`默认为该信号
  * `SIGKILL` - 杀死(kill)进程信号  
    是最强力、完全强制的终止信号，该信号**不能被忽略、处理和阻塞！**  
    因此提供了一种绝对终止进程的方法，使用`kill -9`即为发送杀死信号。
* 错误类信号
  * `SIGFPE` - 运算错误信号
  * `SIGILL` - 操作错误信号
  * `SIGABRT` - 非正常退出错误信号(执行`abort()`)
* 通信类信号
  * `SIGCHLD` - 子进程相关信号
  * `SIGUSR1` - 用户自定义信号1

## 2. 传递信号

* 终端中输入控制字符，即按Ctrl+C等。
* 程序产生
  * `kill()`  
    *注意不是终端中的`kill`，并不能杀死进程。*
  * `alarm()`/`setitimer`
  * `raise()`
  * `abort()`
  * `sigqueue()`

## 3. 处理信号
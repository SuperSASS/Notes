# 第二节 Thread - 线程

一个程序通常由若干个函数(function)构成，  
每个函数功能所需资源、执行方式等均不相同，  
若放在一个进程中串行处理会导致利用率低，各功能之间相互限制，  
因此考虑将每个独立功能分开。

但一个进程互相是隔离的，资源不互通，  
不能将每个功能分为一个进程。

因此提出线程概念，其来自于一个进程，资源共享，  
但执行是分开的。

## 一、线程和进程

### 1. 多线程

拥有的资源：

* An ecexution state.
* Saved thread context when not running.
* An execution stack.
* Some pre-thread static storage for local variables.
* Access of

每个线程占用资源少，很容易创建、终止和切换。

---

线程状态：

* Running
* Ready
* Blocked

线程操作：

* Spawn - 派生
* Block
* Unblock
* Finish

线程执行：

* 需要于进程同步。（进程挂起、线程均挂起）

## 二、线程的分类

分为用户级线程(ULT)和内核级线程(KLT)。  
区别在于：OS是否知道线程的存在。

注意：这里的用户和内核与之前的用户模式、内核模式等概念不一样。  
这里指的是内核对线程的知情度，之前指的是一种权限模式。

### 1. User Level Thread(ULT) - 用户级线程

管理线程的所有工作都由应用程序（进程）完成，  
内核（OS）意识不到线程的存在，其只管理进程。

应用程序通过使用“线程库”(thread library)的各种“例程”(utility)，进行多线程的各种管理。

缺点：  
进程被挂起，线程也会被挂起。

改进：

* Jacketing

### 2. Kernel Level Thread(KLT) - 内核级线程

OS知道线程的存在。  
OS既管理进程也管理线程。

缺点：  
跟ULT的速度有数量级上的差距。

### 3. Combined Approaches - 混合方法

## 三、Multicore/Multithread - 多核与多线程

### 1. 多核系统上的软件性能

Amdahl’s Law​：
$$
$$

可以从多核系统受益的应用程序：

* Multithreaded native applications - 原生多线程应用程序
* Multiprocess applications - 多进程应用程序
* Java applications - Java应用程序
* Multiinstance applications - 多实例应用程序

## 四、Linux Process/Thread - Linux的进程线程管理

### 1. Linux Process/Thread Model - Linux的进程线程状态图

* Running
* Ready
* Interruptible - 可中断
* Uninterruptible - 不可中断
* Stopped - 停止
* Zombie - 僵死

### 2. Pthread Library - Linux的线程库

* `pthread_create()`
* `pthread_exit()`
* `pthread_join()`
* `pthread_yield()`
* `pthread_attr_init()`
* `pthread_attr_destory()`

## Summary

* ULT&KLT

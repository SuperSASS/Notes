# 第二节 Virtual Memory - 虚拟内存

在上一节的后部分，已经开始把进程分段，并且可以**不连续地存放**。  
因此再次考虑：都分段了，就考虑**不完整地存放**，只把需要的部分存到内存。

## 一、分页

页表可能太长。  
页表的处理：

* 多级页表
* 倒排页表
* 快表TLB

问题：

* 怎么取：在内存中选哪些单元放。
* 怎么放：怎么放到所取单元。

特点：

1. 替换算法
2. 驻留级

### 1. 评价标准

主要考虑：Performance

* Minimize the rate of page faults.  
  最小化**缺页率**。

### 2. Fetch Policy - 取策略

### 3. Placement Policy - 存放策略

决定放在哪一个真实内存的片段中。

之前的BB、NF、FF在此时差异并不大了。

### ４. Replacement Policy - 置换策略

当发生缺页时，要把页换进来。  
评价一个分页的方法，主要就是看置换策略好不好。

目标：  
The page that is removed be the page **least likely to be referenced** in the near futuer.  
在最近的将来，被移除的页**最少可能被访问到**。

#### (1) Optimal Policy - 最优算法(理想模型)

策略：

* Select the page for which the time to the next reference is the longest.  
  选择一个页面，其在后面的时间**最晚被再次访问**，或说下次再访问隔得最久。

就是**严格按照置换目标**执行的策略，因此肯定缺页率最低，是最好最优的。  
但计算机**很难知道将来的访问顺序**，因此基本上不可能实现。

就是最理想的一个策略，但不可能被实现，只能作为一个评价标准。

#### (2) First-in-first-out (FIFO) - 先进先出算法

策略：直接循环置换内存中先被放进来的页。

* Treats page frames allocated to a process as a **circular buffer**.
  把分配给进程的页框都看做一个循环缓冲区（循环队列）。
* All that is required is a pointer that circles through the page frames of the process.  
  只需要一个指针指向这个“循环队列”，  
  当需要换出的时候就把指向的页换出，然后指针++。
* Page that has been in memory the longest is replaced.  
  其实代表的隐含含义是：置换在内存中**滞留了最长时间**的页。

虽然简单，但缺页发生的较多。

#### (3) Least Recently Used (LRU) - 最近最少使用

策略：置换内存中最长时间未被再次访问的页。

#### (4) Clock Policy - 时钟策略

基于FIFO的方法发展，用指针`pointer`来控制循环队列，  
又融合了LRU的思想，需要用一种方法记录该页最近是否被再访问。

思路为：给页框添加一个“使用位”(use)。  
需要换出时，则根据`use`判断。    

* 当`use=1`时，代表最近被访问过，不换出；  
* 当`use=0`时，代表最近未被访问过，换出该页。

**方法：**

每有一个页请求时，先看是否在内存中：

* 若在，则将该页的`use`置1；  
* 若不在，需要放入
  * 若`pointer`所指的页直接能放入（为空闲页），则放入。  
  * 若`pointer`所指的页被使用，且`use=0`：则换出这个并放入。
  * 若`pointer`所指的页被使用，但`use=1`：则**将其`use`置0**，并查找下一个页（`pointer++`）。

在需要换出时，则循环遍历，  
最关键的是当前页`use=1`时，把它置成0，  
这样在都`use=1`转完一圈后，其实就是选择当前`pointer`的页换出。

这样可以近似为，选择了之前最久未被再访问的页换出。  
但肯定不是最精确的近似（甚至可以说效果较差），  
因为全`use=1`下，即便当前所指页前一次就被访问过，`use`还是1，转一圈还是换他。

### 5. 驻留级策略

Working Set Strategy - 工作集策略  
解决驻留级大小变化的方法。

## 二、分段
# 第一节 Memory Management - 内存管理

## 一、概述

内存管理的需求：

* Subdividing memory to accommodate multiple processes.  
  **划分**内存以满足多个进程的要求（存放进程数据在用户区）。
* Memory needs to be **allocated efficiently** to pack as many processes into memory as possible.  
  进程需要被**有效地分配**到划分的内存中，尽可能越多越好。

具有的功能：

* Relocation - 重定位功能  
  当进程从外存装载到内存中时，需要对地址进行转换和重新计算。
* Memory Protection - 存储保护  
  对于不同的进程（甚至是父子进程），需要保护各自分配的内存不被互相影响，否则应定义为非法访问而终止操作。
* Memory Sharing - 存储共享  
  将多个进程常用的相同功能（如打印）进行共享，避免空间浪费、提高内存空间利用率。
* Logical/Physical Organization - 逻辑/物理组织  
  程序在外存和内存中的组织是不同的，前者是逻辑组织；后者是物理组织。

## 二、功能

### 1. Rolocation - 重定位

为什么需要重定位：

* Programmers typically do not know in advance **where** programs executed by both themselves and others **will be resident in main memory**.  
  程序员通常不知道自己以及其他程序运行时，存放在内存的哪里。  
  但OS必须清楚地知道程序执行时的地址。
* Active processes need to be able to be **swapped in and out** of main memory in order to maximize processor utilization,  
  为了最大化处理器使用率，活跃进程会被换入换出内存。  
  but it may be swapped to disk and returned to main memory at a **different location** (relocated).  
  但换入时，不一定回到原来的地址，因此需要重新计算新的物理地址。
* Memory references(存储引用) must be translated in the code to actual physical memory address.  
  “存储引用”时需要将代码翻译为实际的物理地址。
  > 定义 - 存储引用：
  >
  > 指的就是程序里调用函数时，只用写函数名便能调用该函数。  
  > 如程序里用`printf()`函数，直接写该函数名便能调用，但此时并不知道`printf()`函数代码装载在内存的的地址。

什么时候需要重定位：

* When program **loaded** into memory the actual(absolute) memory locations are determined.  
  当程序装入内存后，实际存储的地址（物理地址）就需要被决定。
* A process may occupy different partitions which means different absolute memory locations during **execution** (from **swapping**).  
  一个进程在执行（或者换入换出）时可能占用不同分区，即占用不同物理地址。
* **Compaction** will also cause a program to occupy a different partition which means different absolute memory locations.  
  当使用“紧凑技术”(Compaction)时，程序也会占用不同的分区和地址，需要再次转换。  
  > 简介 - 紧凑技术：
  >
  > 将内存空间中碎片化（不同程序占不同空间，互相不是连续的）的内容和地址，  
  > 通过移动变为一端是被占用的部分，另一端是空闲的部分。

即：进程装入内存、换出换入后、存储引用、使用紧凑技术时。

### 0. 地址

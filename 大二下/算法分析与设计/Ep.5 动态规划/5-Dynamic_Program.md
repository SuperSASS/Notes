# Ep.5 动态规划

在穷举和分治的基础上进行优化，  
相当于减枝的搜索。

但与分治不同的是，**子问题之间可能并不独立**（分治法中子问题要求相互独立），  
并且并不能很明确地划分成若干个子问题，而是在实际求解过程中进行分解。
同时在计算子问题的时候，会将子问题的解保存下来。

主要利用递归的方法，  
需要转化为递推。

## 例1 - 矩阵连乘

对于矩阵的连续相乘，其满足结合律，  
而乘法的顺序不同，会造成乘法运算的次数不同。

如何求：$A_{P_1P_2}\times A_{P_2P_3}\times A_{P_3P_4}\times\cdots\times A_{P_{n-1}P_n}\times A_{P_nP_{n+1}}$的乘法次数最小的方法。

**分析：**  
无论怎么结合，其矩阵的相对位置不变，  
因此最后得到的肯定是矩阵$A_{P_1P_{n+1}}$。

从最后开始**倒序分析**，最后一步是由$A_{P_1 P_K}\times A_{P_K P_{n+1}}$得到的，分别为左右两部分相乘。  

* 左部分为：$A_{P_1P_2}\times A_{P_2P_3}\times\cdots\times A_{P_{k-1}P_K}$
* 右部分为：$A_{P_KP_{K+1}}\times A_{P_{K+1}P_{K+2}}\times\cdots\times A_{P_nP_{n+1}}$

乘法次数：$P_1*P_K*P_{n+1}$。

为“穷举”+“减治”法。

**动规方法：**

我们用$dp[i][j]$来记录得到矩阵$A_{P_iP_j}$的最小乘法次数，  
可以得到以下动态规划方程：
$$
dp[i][j]=\min(dp[i][k-1]+dp[k][j]+P_i*P_k*P_{j+1})\\(k\in[i+1,j-1])
$$
边界条件：$dp[i][i]=0, dp[i][i+1]=P_i*P_{i+1}*P_{i+2}$

要得到方法，记录每次$k$所取的值。

## 例2 - 最长递增子序列

**分析：**

这里是**顺推**，  
先从只有一个元素开始，此时$dp[1]=1$，  
添加一个元素后，其如果比前面的元素大，则此时长度为$dp[k]+1$，  
若比前面的元素小，则此时应选取之前的子序列，作为当前位置的最大子序列，及长度为$dp[k]$。

为“穷举”+“增治”法。

**动规方法：**

用$dp[i]$记录$i$位置之前的最长子序列。
$$
dp[i]=\max((a[k]<a[i])?(dp[k]+1):(dp[k])) \\
(k\in[1,i-1])
$$

边界条件：$dp[1]=1$

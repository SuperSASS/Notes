# 一些笔记

## 一些基本术语

* **Compilation - 编译**
  就是都快按烂的那个“Start Compilation”按钮
  具体过程在下面[为什么我的Verilog代码最后就能变成在板子上跑的电路？](#为什么我的verilog代码最后就能变成在板子上跑的电路)讲解。
* **RTL(Register Transfer Level) - 寄存器传输级电路**  
  在Quartus中就是利用在"Tools" - "Netlist Viewers"中的"RTL Viewer"查看。  
  有关这个的详细讲写在下面[为什么我的Verilog代码最后就能变成在板子上跑的电路？](#为什么我的verilog代码最后就能变成在板子上跑的电路)讲解。
* **综合**  
  将所写的Verilog代码，翻译成各种电路上的实际器件和连线。基本的如“与或非”门，以及由这三个衍生发展的“选择器”、“触发器”等等。
* **可综合**  
  自然就指：指所写的Verilog代码，能够翻译成各种电路上的各种器件。这是所写Verilog代码必须保证的一点，不然很容易跟自己所选的代码发生很大偏差。

## 为什么我的Verilog代码最后就能变成在板子上跑的电路？

> 在这之前，可以先重新认识一下什么是FPGA，  
> 可能很多人确实不是很了解，只是跟着理论课实验课上的代码写，上传到板子上发现能跑，  
> 哇！感觉神奇，虽然有时候可能会想弄明白这到底怎么实现的，但最终还是那句「能跑就行」。  
> 可看：[fpga是什么意思（fpga怎么用）](https://zhuanlan.zhihu.com/p/78218055)

大部分同学通病：过早的接触C++类编程语言，导致学习Verilog时被很严重的影响。  
**从现在开始：忘掉你学的C++！**

但偶尔也可以通过类比，来找到实际上有什么区别：  
最开始的疑惑可能就如题目所示。  
下面通过类比来回答：

> 比如C这类编程语言，回答“为什么我的C代码最后就能变成在计算机上跑的程序？”  
> 需要知道**最终目的：把“高级语言”翻译成“机器语言”**。
>
> 虽然很简略，也不全部适用（比如解释型语言），但常用的大致可以分为这两步：
>
> 1. 将“高级语言” 翻译成 “汇编语言”
> 2. 将“汇编语言” 翻译成 “机器语言”
>
> * “高级语言”：就是你写的代码
> * “汇编语言”：机器目前虽然不懂，但Ctrl+H替换一下马上就能懂；而你慢慢看勉强也能看懂，但太痛苦了。
> * “机器语言”：机器唯一能懂的语言，本质是一条条指令，计算机会很死板的、准确的、按顺序的一条条执行这些指令。
>
> 因此汇编语言相当于一个桥梁，沟通起了我们很好懂的“高级语言”和计算机只能懂的“机器语言”，  
> 但是“机器语言”与“汇编语言”之间只是替换（就像宏，`#define ADD 01011011`这样），中间**不存在信息丢失**；  
> “汇编语言”与“高级语言”之间就存在了抽象了，**有抽象基本上就有信息丢失**，高级语言会翻译成怎样的汇编语言全看“编译器”的心情。  
> 【更多详细知识就属于“编译原理”的事啦，有兴趣自己再去了解吧√……

类比！首先需要知道**最终目的：把“硬件描述语言”翻译成物理上的“电路图”**。  
对！就是你**模电**（或者高中物理课上电学部分）学的那种**电路图**。
Verilog这类硬件描述语言变成边路可以大致分为如下几步：

1. 将“硬件描述语言” 翻译成 “门级电路”
2. 将“门级电路” 翻译成 “物理电路图”

我们电路用的Quartus，就像我们编程用的Visual Studio或Dev-C++等**IDE**，  
都是直接**一步到位**，实现上面提到的最终功能的。

将“硬件描述语言”翻译成“门级电路”这个步骤是一定要知道的。  
也就是：我们写的Verilog代码，最后都会翻译成一个个“**与或非门**”和各种“**连线**”组成的东西。

其中这个翻译过程中上还有一层抽象，就是“RTL”，在上面基本术语中提到的的。  
其就是在**纯门级电路**的基础上，用选择器、触发器、寄存器等**由门级器件集成的基本部件**，进行了简单的代替。  
*（因此甚至可以理解为：纯门级电路就像机器语言，RTL就像汇编语言）*

具体的"RTL"含义可以自行查询了解。

因此怎么检查自己编译后的结果，是否负责自己的预想呢？  
**最简单最好用方法：查看“RTL”！**  
**最后的实现，是根据RTL画成什么样子**，而不是根据你代码写成什么样子。

---

前面翻译成门级电路都与芯片具体信号无关的，因为就是把你写的翻译成各种门，
然后，“门级电路”到“物理电路图”实现这里更内核，没过多了解，但其实这部分也挺重要的【rua因为实在没精力再深入了解了作业都做不完了orz……

其实真正把Verilog翻译成电路图，要依次完成以下四步：

1. 编译
2. 映射
3. 布局
4. 布线

对应一下**Quartus左边那个状态栏那几个步骤**：

1. “Analysis & Synthesis” - 分析和综合  
   * 分析完成的是语法检查。
   * 综合完成的是“编译”和“映射”。
2. “Fitter (Place & Route)” - 装配 (布局和布线)  
   完成的是“布局”和“布线”。
3. “Assembler (Generate programming files)” - 汇编 (生成编程文件)  
   这步就是生成你烧录到板子上的文件`*.sof`。
4. “Timing Analysis” - 时序分析
5. “EDA Netlist Writer” - 产生EDA工具网表  
   *最后这两个不是很了解，但从代码到上传的文件只在前三步完成，先认识这三个就行。*

*具体可以查看：[QUARTUS工具analysis&synthesis fitter assembler timequest timing analysis eda netlist writer的作用](https://blog.csdn.net/weixin_44884357/article/details/105988802)。*

再回到之前提的那两步：  
前一步主要是“编译”；这一步主要负责“映射”、“布局”、“布线”。

因此到这一步开始就**跟具体芯片有关**了，不同芯片会映射成不同的LUT、有不同的布局和布线。  
这里翻译出来的结果同样可以在之前查看RTL的地方，选下面的“Technology Map Viewer”  
“Post-Mapping”是映射后的图；“Post-Fitting”是布局布线后的图。

虽然没有具体了解，但这里有一个可能会见到的警告，就与这里有关：  
> Warning (332125): Found combinational **loop of `*` nodes**

指的是在这一步的时候，生成了循环线路（或者说直接反馈），如下图所示：  
![循环线路](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_16-37-36.png)  
虽然不是很懂这个图，但学过模电就知道：直接把输出接回输入感觉起来就很恐怖。  
所以以后再出现这个警告时可不能忽视了！
*【想起来之前都不知道这个警告什么意思，然后双击也不能跳转问题在哪，所以就没去解决了……*  
*【现在一看感觉问题还挺严重的，原来有次甚至出现过有600多个节点报这个警告【……*

具体可以查看：[谈谈FPGA设计的实现过程](https://zhuanlan.zhihu.com/p/130916138)。

## 组合逻辑电路和时序逻辑电路的深刻认识

无论如何，数字电路分为：组合逻辑部分和时序逻辑部分。

就这两个，没别的。

### 1. 最核心的区别

* 组合逻辑电路：异步、电平敏感(`always @(...)`)、串行（阻塞）  
  * 输出取决于：输入。  
  * 什么时候更新输出：敏感**端口信号**变化（高低电平的转换）。  
* 时序逻辑电路：一般最好同步（这里再异步就属于高玩弄的了）、边沿敏感(`always @(posedge/negedge ...)`)、并行（非阻塞）  
  * 输出取决于：输入和**前一状态**。
  * 什么时候更新输出：敏感**时钟信号**变化（上升下降沿）。

并行性可以参考：

* [verilog的并行性](https://blog.csdn.net/Gaojk1/article/details/121070970)
* [Verilog中的顺序和并行](https://zhuanlan.zhihu.com/p/35442938)
* [Verilog中语句执行顺序的理解](https://blog.csdn.net/gsp12356/article/details/104910763)
* [always@(posedge clk)时序赋值延迟一个周期](https://blog.csdn.net/MaoChuangAn/article/details/103977287)'

### 2. 两者的执行顺序

对于两种语句块`always`，  
假如某一触发边沿，组合和时序部分同时变换，  
之间的过程可以记为：

1. **先**执行**组合逻辑**部分，并且：
   * 块内：串行执行  
     如果使用`always @(*)`，阻塞和非阻塞最终效果一样，但推荐只用阻塞式。  
     有关为什么两种效果一样，可以见[详解如何使用“非阻塞赋值”描述组合逻辑](https://baijiahao.baidu.com/s?id=1678759624264829059)说的「在这个例子中，我们将out1和out2放到了敏感变量列表里面（相当于`*`），这样虽然仿真正确，但是不推荐」。  
     有关为什么推荐只用`always @(*)`，可见后面[敏感信号相关](#2-敏感信号相关)部分。
   * 块间：串行执行  
     注：虽然经过验证确实是串行执行，但组合逻辑各个`always`块是不可能相互嵌套的，  
     所以虽然某个前面的语句块要依赖后面的语句块的信号，但在后面那个语句块该信号变化后，又会被前面那个语句块捕捉到并再次更新。  
     所以在这里讨论块间的串并行没有意义，最终都会**保证所有的信号都按照赋值顺序逐步传递下去**。
     > 拓展 - 为什么不可能互相嵌套：
     >
     > 这里的互相嵌套，指的是：假如有两个块`A`、`B`，  
     > **不可能**`B`的一个信号`B_out`作为`A`的敏感信号；  
     > 而`A`的一个信号`A_out`作为`B`的敏感信号。
     >
     > 动动脑筋想想，如果这样会发生什么：  
     > 假如`A_out`首先变化，会引起`B_out`变化，而`B_out`变化又引起`A_out`变化，搁这无限递归起来了。
     >
     > 拿下面这串代码在ModelSim里仿真一下，会出现很奇妙的提示：
     >
     > ```v
     > `timescale 1 ns/ 1 ns
     > module test();
     >     reg a = 0, b = 0, c = 0;
     > 
     >     always @(*) // *对应a和c
     >     begin
     >         b = a ~^ c;
     >     end
     > 
     >     always @(*) // *对应a和b
     >     begin
     >         c = a ^ b;
     >     end
     > 
     >     initial
     >     begin
     >         #35 a = 1'b1;
     >         #75 a = 1'b0;
     >     end
     > endmodule
     > ```
     >
     > ![ModelSim提示](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_17-27-35.png)  
     > 意思就是：反复迭代超过了最高次数限制。
     >
     > ---
     >
     > 部分人还可能会想：如果让`always`各自不捕捉`c`、`b`的变化，只对`a`敏感呢？  
     > 并且两个都改成异或，如下：
     >
     > ```v
     >     `timescale 1 ns/ 1 ns
     >     module test();
     >         reg a = 0, b = 0, c = 0;
     >     
     >         always @(a)
     >             b = a ^ c;
     >     
     >         always @(a)
     >             c = a ^ b;
     >     
     >         initial
     >         begin
     >             #35 a = 1'b1;
     >             #75 a = 1'b0;
     >         end
     >     endmodule
     > ```
     >
     > 这样确实在ModelSim中能仿真了，  
     > 并且能发现两个`always`语句块顺序不一样，`b`和`c`的值也不一样。  
     > ![b在c前](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_17-42-42.png) ![c在b前](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_17-42-46.png)
     > 【因为这里其实就是这样发现的_(:зゝ∠)_……
     >
     > 但！这样到Quartus是编译出来会有问题，其又跟预想的不一样，  
     > RTL如下：  
     > ![RTL图](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_17-44-44.png)  
     > 总之就是变成了不可控制的反馈电路【应该是这么叫的吧……
2. **再**执行**时序逻辑**部分，并且：
   * 块内并行执行（除非用阻塞式）
   * 块间并行执行

### 3. 从组合逻辑电路被迫x发展到时序逻辑电路

众所周知，数字电路可以且**只能分为两种**：“**组合逻辑电路**”和“**时序逻辑电路**”，没有其它！  

组合逻辑最开始学的，还是很好理解的，也很符合我们的认识，  
根据输入立刻得到输出，就跟C语言里的“函数”一样嘛，不错不错。  

但到时序逻辑电路就可能有点疑惑了，为什么要加个时钟信号，为什么要同步变化等等问题。

下面这里用个人认为比较生动的两个例子（全是自己编的，很辛苦的qwq！）来讲述组合逻辑电路的形成，以及为何要发展成时序逻辑电路。

---

组合逻辑特点是：**即时响应，反应快**。  
但因为所有人都想反应就反应，会很乱，甚至造成错误。  
最典型的错误就是数电学的“竞争与冒险”，也就是会造成“毛刺”。

在“电子”的世界里面，想要有序可不那么容易，都是自顾自的冲就完事。  
最主要的原因，是因电子为没有“时间”这个概念。

我们现实世界所有的“有序”都必须要有时间的存在。  
比如排队：先来先服务，这个“先”就必须要有时间概念；  
又比如各种事件的安排，都必须要**精确到某个时间点**上（即便说明天做作业，也是在明天某一时刻开始做作业的）。  
*而那些说「有钱再还你钱」而不是好久还你钱的人，最后统统都很难还上钱。*
> 但我们需要时间概念，其实也是为了有一个“**周期**”或说时间差这种相对的概念，  
> 绝对的一个时间点是没意义的，只有存在另一个时间点，或者一整个时间线才有用。
>
> 最开始的时间单位是“天”这种粗略的时间间隔，因为**一天就是天亮和天黑这样一个周期**，方便观测。  
> 但天太粗略了，所以后面不断划分成时、分、秒等时间单位，但本质还是周期。
>
> 可以看如今对时间基本单位“1秒”的定义：
>> 铯-133原子基态的两个超精细能级间跃迁对应辐射的9,192,631,770个**周期**的持续时间
>
> 再看各种不同的对基本时间“1秒”的定义，基本上都是用某个客观存在的，在反复运行、周期运动的东西（如地球自转、公转等周期运动），来划分出我们的时间定义。  
> 是不是有点数电中**分频**的意味在里面，数字电路里对应的“铯-133原子”就是我们给的时钟震荡`CLK`，再不断分频成其需要的时间单位。

下面考虑这样一个世界：那里的人只会种田（行为只有播种和收获），  
但人**不需要睡觉**，种的植物**无论如何都能健康成长**直到收获（就是不考虑节气等时间带来的影响）。  
那这样的一个世界，这些人**根本不用存在“时间”这一概念**！

是不是感觉没时间概念很恐怖，但仔细一想好像确实不用管时间这东西，  
反正就一直守在田里，作物好了就收获并再种（也不用管从播种到成熟要好久，反正人只负责播种和收获）。
抽象一下就是：

```v
always @(庄稼成熟)
begin
    收获;
    播种;
end
```

这是不是就有我们组合逻辑的味道！  
这个时候，只有一个人，**随便干也不会影响到别人**，所以完全不用考虑时间，**不需要什么“同步”**。

这样就自然而然地形成了我们组合逻辑电路，其诞生的目的是：  
**根据某个现象，立刻地做出相应的行为。**  
并且发生的现象（输入）与所做的行为（输出）基本上是一一确定的关系（偶尔也可能是多输入对一输出，但不可能是一输入对多输出），  
其描述方法是用“**真值表**”，所有输出都可以根据输入提前确定。

---

但再考虑下面这种情况：  
在名为“地方”的行星上，有两位天然呆，她们的上帝“淺真”给这两位安排了一个游戏：
> 淺真会同时给两位一个运算式，然后要她们自己计算结果，并按照要求回答相应答案。
>
> 淺真给了她们两一个Pad，上面有淺真分别给两人的运算式，以及一个输入栏来回答问题，需要两位共同决定答案，要求如下：  
>> 如果两个运算结果**只有一个小于$10$**，就在输入栏回答「**真**」(`1`)；  
>> 否则，如果两个都小于$10$，或没有小于$10$的，就回答「假」（`0`）。
>
> 如果答对，则两位都可以得到跟淺真一起玩ff14的机会；  
> 如果答错，两位要替淺真写这篇难写的文章。
>
> 淺真保证：所有的运算式最终都能算出一个确定的有理数！（这里最终就是指能在有限的时间内运算出来，但小声点！A、B这个时候还不知道“时间”这一东西呢……

虽然那样保证了，但淺真「诶嘿」一声，准备使坏：  
她给第一位的运算式是如$4+3$、$13-1$这样直接非常简单的运算式；  
而给另一位却是如$\sum_{k=1}^{5724}\frac{(-1)^k}{e^k}$、$\int_{-\infty}^{+\infty}e^{-x^2}$这样比攻略绝巴哈还难的运算式。

第一位开心极了，直接$1\textrm{ns}$内就能计算出结果并判断出大小，但第二个人就没那么舒服了。  
好在第二位足够聪明，虽然不能$1\textrm{ns}$内直接判断出大小，但最终也总能在$100\textrm{ns}$内计算出结果并判断大小。

这个时候，假设两位还是没有进化出“时间”这种概念，  
像那位一直种田的那样，是这样的逻辑：

```v
integer 计算结果;
always @(淺真给出表达式)
begin
    计算结果 = 表达式结果; // 这里根据运算式的难度，需要不同的时间运算
                         // 反映到实际电路中则是：信号经过逻辑门个数不同，会造成不同程度的**延时**
                         // 这里我们假定：B**最慢也会在100ns内**计算出表达式。
    if (计算结果 < 10)
        我鉴定为：真！;
    else
        我鉴定为：假！;
end
```

翻译翻译成Verilog语言：

```v
integer Calc_Result = 0; // 运算式计算结果
reg    Judge_Output = 0; // 大小判断结果

always @(Ques_x, Ques_y) // 假设计算式为加法
begin
    #x Calc_Result = Ques_x + Ques_y; // x为计算所需时间

    if (Calc_Result < 10)
        Judge_Output = 1;
    else
        Judge_Output = 0;
end
```

然后两位分析出了淺真的要求：「就是把我们两个各自的判定结果进行“异或运算”嘛……」，  
于是她们找来了一个“异或门”，让其接入她们两的判断结果，再直接把其异或结果输出到平板里就行啦。

---

第一道测试来袭！其结果应该为「假」！

> 两人的测试模块如下：
>
> ```v
> `timescale 1 ns/ 1 ns
> module The_Ques_Given_From_SuperSASS();
>     // 这里为了仿真，假设淺真给两位的都是两个一位数(x,y)
>     // 运算式就是x+y，但B就是要50ns才能做出来……
>     wire [3:0] Ques_Give_to_A_x;
>     wire [3:0] Ques_Give_to_A_y;
>     wire [3:0] Ques_Give_to_B_x;
>     wire [3:0] Ques_Give_to_B_y;
> 
>     // 第一位A的判断模块
>     integer A_Calc_Result = 0; // A的运算式计算结果
>     reg    A_Judge_Output = 0; // A的大小判断结果
>     always @(Ques_Give_to_A_x, Ques_Give_to_A_y)
>     begin
>         #5 A_Calc_Result = Ques_Give_to_A_x + Ques_Give_to_A_y; // A只用5ns就能计算出结果
>         if (A_Calc_Result < 10)
>             A_Judge_Output = 1;
>         else
>             A_Judge_Output = 0;
>     end
> 
>     // 第二位B的判断模块
>     integer B_Calc_Result = 0; // B的运算式计算结果
>     reg    B_Judge_Output = 0; // B的大小判断结果
>     always @(Ques_Give_to_B_x, Ques_Give_to_B_y)
>     begin
>         #50 B_Calc_Result = Ques_Give_to_B_x + Ques_Give_to_B_y; // B要50ns后才能计算出结果
>         if (B_Calc_Result < 10)
>             B_Judge_Output = 1;
>         else
>             B_Judge_Output = 0;
>     end
> 
>     // 找来的异或门
>     wire Answer_from_XOR_Gate; // 异或门输出
>     xor(Answer_from_XOR_Gate, A_Judge_Output, B_Judge_Output);
> 
>     // 淺真通过PAD给出题目，并接受A、B两位的答案
>     PAD Communicate_With_SuperSASS(
>             Ques_Give_to_A_x,
>             Ques_Give_to_A_y,
>             Ques_Give_to_B_x,
>             Ques_Give_to_B_y,
>             Answer_from_XOR_Gate
>         );
> endmodule
> ```
>
> ---
>
> 淺真给的第一次测试如下：
>
> ```v
> `timescale 1 ns/ 1 ns
> module PAD(
>         output reg [3:0] Ques_I_Will_Give_to_A_x = 0,
>         output reg [3:0] Ques_I_Will_Give_to_A_y = 0,
>         output reg [3:0] Ques_I_Will_Give_to_B_x = 0,
>         output reg [3:0] Ques_I_Will_Give_to_B_y = 0,
>         input The_Answer_They_Give_to_Me
>     );
> 
>     // 第一次测试，将在10ns后下发！
>     initial
>     begin
>         #10;
>         Ques_I_Will_Give_to_A_x = 3;
>         Ques_I_Will_Give_to_A_y = 4;
>         Ques_I_Will_Give_to_B_x = 9;
>         Ques_I_Will_Give_to_B_y = 0;
>     end
> 
>     // A的判断应为“真”，B的判断应为“真”，
>     // 所以两人给我的答案应该是：“假”。
>     always @(The_Answer_They_Give_to_Me)
>     begin
>         if (The_Answer_They_Give_to_Me == 0)
>             $display("回答错误啦！【拍……");
>         else
>             $display("竟然是回答正确……");
>     end
> endmodule
> ```

在`A`、`B`的“地方”行星上面看：  
![A、B那边的结果（组合逻辑）](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_00-11-45.png)  
从整个过程来看，虽然B慢了一会，但最终还是判断出来了，  
`A`算的很快，一会就判断出她自己的结果为`1`，此时`B`还没算出来，默认为`0`，  
因此：**“异或门”会有一段为`1`的输出时间**！  
在`B`判断出来后，“异或门”输出才为正确的`0`。

但！这个时候乖乖的“异或门”可什么也不知道，是**原封不动的把两人的结果异或后输出**，  
淺真这边一看，浅笑一下说「中计了！」，直接一个`机组总结.md`文件就发送到她们两那去了，  
还附了一张截图如下，说：  
「你们两人提交的结果为“真”(`1`)，是错误的！就算是记得到我的名字也不会原谅你们的！」  
![淺真那边发送的测试数据以及收到的答案（组合逻辑）](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_03-31-01.png)  

两人哑口无言，**虽然最终是得到了正确答案，但毕竟还是有`1`这个错误的输出**，  
就像考试：先交了份答案是错的，后面才改为了正确答案，但老师已经把之前交的试卷改了分数都出来了，  
有截图在那铁证如山，只得接受惩罚了orz。

出现这种情况，正是因为淺真知道她们两现在处于“组合逻辑”阶段，并且找到的异或门也是组合逻辑的，  
淺真还知道，**对于“组合逻辑电路”，在一端改变输入后，其输出也会立刻受到影响**。  
于是就利用这个特性，专门给两人出了**用时不同**的计算式，从而**导致有一段时间的错误输出**。  
这个错误的输出，对应课上所学的就是：“竞争冒险导致的**毛刺**”。

在这个例子中还影响还不算严重，因为淺真是上帝嘛，见的多啦！  
在接收到了这个错误输入后，只是给了两位小小的惩罚，并没有被其影响。  
但如果换做其他的天然呆呢，或者说逻辑门？  
这个错误的信号，可能就像某种病毒一样，在所经过的地方留下神必痕迹，  
并被他们不断传递下去，传到各个地方去，最终感染了整个电路，导致电路腐化！  
> 比如假设对于电脑，有个最终的判断电路负责控制“重启”操作，会接受来自CPU、内存、各种硬件的一个“发生异常”信号，  
> 为高电平有效，即：默认为低电平`0`，如果设备异常其变为高电平`1`。  
> 如果其中有一个设备发生异常（或运算），就会执行“重启”。
>
> 因为电路本身的缺陷，其可能会出现错误的“异常信号”，  
> 即便人们已经很努力了！但最多只能控制到其不会连续出错超过$10\textrm{ns}$（意思是即便出错为`1`，也会在$10\textrm{ns}$内恢复正常到`0`）。  
> *可别小看这些这些很短暂的错误信号，以及上面例子的毛刺信号，就是因为逻辑门无论如何都有延迟时间不可能被消除，所以其影响在组合逻辑中无法避免。*
>
> 假如就采用这种组合逻辑电路实现的该电脑这一判断电路，  
> 那可能过个几分钟，就有设备发出了错误的“异常信号”，  
> 还没来得及修正，就被这什么事都干的最积极最及时的判断电路给接收并处理了，直接宣布重启！
>
> 这种几分钟就重启一次的电脑，我相信你也不想这样的对吧！  
> 那就好好学学接下来的时序逻辑电路，让你的电脑身经百战而屹立不倒！

---

`B`边写笔记边向`A`抱怨：「你明明知道我要运算很久，但我最终也会运算出结果并正确判断大小的！为什么不等个很长时间，然后我们两再同时向异或门输出大小判断结果呢？！」  
结果`A`却说了句「？」，`B`也明显没意识到问题的严重性：她竟然说了「**等**」、「**同时**」这两个词！  
在没有“时间”观念的情况下，是完全不存在“等”这个词语，更别说“同时”了。  
可见连`B`这位没有“时间”观念的天然呆，都顺理成章（被逼无奈）地进化出了“时间”这个概念，  
知道了：**要等一段时间，两位都运算出结果后，再同步地去判断大小并输出给异或门。**

那**如何引入时间这个概念**呢？想想我们如果没有表或其他计时工具，要计时是怎么做的，  
是不是在心里默默计时：「1、2、3、……」，  
但这个计时加1的间隔是由什么决定的呢？其是由我们平时对“一秒有多长的感觉”决定的，  
这个感觉可很不准，因此心里计时计久了就有很大偏差。

对于“电子们”来说，首先它们本身就没有时间的感觉，不知道一秒有多长，没法靠自己计时；  
其次也**无法容忍这种模糊不精确的时间**感觉。

回到之前拓展内容提到的，要引入一个像“铯-133原子”那样有稳定周期运动的东西，基于此得到一种时间的概念。  
这是不是就是我们一直用的`clk`**时钟信号**了？稳定！周期变化！  

突然，一位名为`clk`的成熟大姐姐突然从天而降来到这个世界，  
她的特性就跟我们平时用的时钟信号一样，能以稳定的周期在`1`和`0`之间反复横跳，  
然后`clk`还跟`A`、`B`做了朋友，  
为了庆祝这一时刻，她们还把自己的行星名字改成了“地球”【x……  
于是：`A`、`B`两人在有了时间观念后，突然大进化！  
两人关上了VSCode不再继续帮淺真写笔记，而是准备再挑战淺真大魔王。

首先她们要求时钟信号`clk`每$100\textrm{ns}$变化一次，  
然后她们变成了以下形式：

```v
integer 计算结果;
always @(淺真给出表达式)
begin
    计算结果 = 计算表达式结果; // 记得我们的假定：B最慢也会在100ns内计算出表达式。【如果B最慢要1000年运算出来，就让clk每1000年变化一次就好啦……总之是有限时间的嘛……
end

always @(clk告诉我们：该同步判断大小啦)
begin
    if (计算结果 < 10)
        我鉴定为：真！;
    else
        我鉴定为：假！;
end
```

同时她们约定，在`clk`从低电平`0`翻转到高电平`1`，即**上升沿时，我们再同步判断**。  
*注：其实也可以约定在`clk`为高电平`1`时同步判断啦_(:зゝ∠)_……不过这属于一个锁存器Latch；如果是在边沿判断则属于触发器Flip-flop。*  
*这两者的区别后面再讲，这里先就约定用上升沿！*

*注注: 部分同学意思可能是，只是`always @(posedge clk)`改为`always @(clk)`，也就是`clk`变化的时候进行判断，而不是`always @(clk, input)`。*  
*即只在变化那一瞬间判断，后面即便输入改变也不会进行判断。*  
*但动动你的小脑袋想想：这跟只在边沿判断有区别吗.jpg*

> 再拓展 - 部分不信邪的同学（比如我x）可能想要躬身力行一下：
>
> ```v
> module test(Output_Ans, CLK, Calc_Result);
>     output reg Output_Ans;
>     input CLK;
>     input [3:0] Calc_Result;
> 
>     always @(CLK)
>     begin
>         if (Calc_Result < 10)
>             Output_Ans = 1'b1;
>         else
>             Output_Ans = 1'b0;
>     end
> endmodule
> ```
>
> 可能想的是：  
> 这样也只在`CLK`每次变化进行检测，甚至“低电平变为高电平”和“高电平变为低电平”都会检测，  
> 可以翻译为`always @(posedge CLK, negedge CLK)`了，机智如我！
>
> 但先来看看翻译后的RTL：  
> ![上面神必代码翻译的RTL图](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_01-42-26.png)  
> 感到神必，为什么翻译出来是个比较器，甚至`CLK`直接接地了？  
> 仿真出来的波形自然不用多说，直接随输入`Calc_Result`同步变化的，根本与`CLK`无关。  
> 宣告这个想法的失败。
>
> ---
>
> 不信邪，改成下面的方式：
>
> ```v
> module test_module(Output_Ans, CLK, Calc_Result);
>     output reg Output_Ans = 0;
>     input CLK;
>     input [3:0] Calc_Result;
> 
>     always @(CLK)
>     begin
>         if (CLK  == 1'b1) // 只在高电平判断（相当于上升沿）
>         begin
>             if (Calc_Result < 10)
>                 Output_Ans = 1'b1;
>             else
>                 Output_Ans = 1'b0;
>         end
>         // 没写else哦！但相当于：else Output_Ans = Output_Ans;【而且本来也就想表达这个意思
>     end
> endmodule
> ```
>
> 感觉对应的应该是`always @(posedge CLK)`，但就是傲娇，不想这样写。
>
> 首先看到的就是这样一条熟悉的警告：  
> ![10240，又是它！！](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_01-49-12.png)  
> 就感到大事不妙了，查看一下RTL：  
> ![锁存器，又是它！！](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_01-50-44.png)  
> 果然是锁存器"$latch"。  
> 波形自然不多说，就是锁存器波形：  
> ![毛刺，又是它！！](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_04-36-42.png)  
> `CLK`为高电平有效时，输出同输出一直；`CLK`无效时，输出保持原来的状态。
>
> ---
>
> **主要原因是（重点）：**
>
> 第一种想法虽然好，第二种想法也整点花的，但最终都与所想大相径庭，就是因为需要注意这点：  
> Verilog是硬件描述语言，跟我们熟悉的`C++`很像（比如语言风格），但**绝对不是一样**的！  
> **一定要好好地理解这一点**，不然之后犯的各种错误，都会在想：“为什么跟我用C++编程思维想的不一样呢？”，跟容易跟编程语言进行类比但得不出答案！
>
> 最重要的两点常见区别为：
>
> * 第一点 - 串行与并行的区别
>   * C++类的“程序设计语言”：各行代码一般都是串行执行的（除非多进程多线程，但我们目前设计的一般都是单进程单线程），**语句是一条条顺序执行的**。
>   * Verilog类的“硬件描述语言”：**各语句块（`always`）之间是并行执行**的，**语句是一批批同时执行的**，之间执行顺序不确定，赋值分为现态和次态。
>
> > 现态和次态就是数电上讲的$Q_n$和$Q_{n+1}$，  
> > 一定要注意$Q_{n+1}$只由其它变量的$Q_{n}$决定，而不能由$Q_{n+1}$决定！
> >
> > 也就是经常会犯的错误：  
> > 在前面一个`always @(posedge clk)`时序电路中，有`a = 4'b1010;`（注意这里还贴心的写了阻塞赋值哦，认为其它语句块会其被阻塞）；  
> > 后面一个时序电路中，有`b = a;`，  
> > 但仿真却发现并不一定`b == a`（甚至经常跟预想的不一样）。  
> >
> > 这就是因为$Q_{b,n+1}=Q_{a,n}$，**只能**是$a$赋值前的“现态”。
>
> * 第二点 - 翻译的区别
>   * C++类的“程序设计语言”：一般来说你写的是什么，就能**基本准确地翻译成相应的汇编语言**，又能一一对应地翻译成机器语言。你所设想的，就是你的结果。  
>     （就是你怎么想的，一般程序就怎么执行，除非发生一些逻辑或其它各类错误；因为编译器不会大幅度改动代码，最多只是狠狠地优化一下，但底层逻辑不变）
>   * Verilog类的“硬件描述语言”：一般来说不管你写的是什么，它只能翻译成存在的如“与或非”等最基本的门电路，或者尤其组成的如“选择器”、“译码器”、“触发器”等集成器件。部分时候**你想的可能跟它翻译完全不一样**。  
>     也就是说，你所想的功能，就算看起来逻辑正确，**但必须能有对应的基本器件去实现它**，也就是常说的“可综合”，**最终可以翻译成全部由“与或非”基本逻辑们组成的电路图**。  
>     *停一下：很抱歉打扰你，但请问你还记得到RTL是什么吗？不记得的话看看前面的[基本术语](#一些基本术语)。*  
>     也就是理解理解“描述”这个词，只能用来描述我们的想法，但不是“实现”语言，具体时间还得看人家怎么选择就器件。
>
> 对于上面的第一种想法，因为现实就不存在既能在上升沿也能在下降沿触发的时序电路器件（触发器之类的均值能在一个边沿触发），因此**只能擅作主张，把CLK给无视掉**；  
> 对于上面的第二种想法，因为规定了`always @(...)`里不写`posedge`或`negedge`之类的边沿触发方式，就会翻译成“组合逻辑电路”，又因为语句块里有只在`CLK`是高电平赋值，**低电平的话默认为“保持之前值”**操作，因此只能被迫翻译成组合逻辑电路里用的“锁存器”，来存储之前的值。  
> *注：这里也就是后面再详细讲的“经常翻译成锁存器Latch的原因”。*
>
> 【所以你们不要再随便写奇怪的描述语言了！人家Quartus也很为难的！……

翻译翻译成Verilog语言：

```v
integer Calc_Result = 0; // 运算式计算结果
reg    Judge_Output = 0; // 大小判断结果

always @(Ques_x, Ques_y) // 假设计算式为加法
begin
    #x Calc_Result = Ques_x + Ques_y; // x为计算所需时间
end

always @(posedge CLK)
begin
    if (Calc_Result < 10)
        Judge_Output = 1;
    else
        Judge_Output = 0;
end
```

这次再向淺真发起挑战，看看第二次测试！
> 两人的测试模块如下：
>
> ```v
> `timescale 1 ns/ 1 ns
> module The_Ques_Given_From_SuperSASS();
>     // 这里为了仿真，假设淺真给两人的都是两个一位数(x,y)
>     // 运算式就是x+y，但B就是要50ns才能做出来……
>     wire [3:0] Ques_Give_to_A_x;
>     wire [3:0] Ques_Give_to_A_y;
>     wire [3:0] Ques_Give_to_B_x;
>     wire [3:0] Ques_Give_to_B_y;
> 
>     // A、B：「clk！麻烦你每100ns翻转一次，拜托了！」
>     reg CLK = 0; // clk，参上！
>     always
>     begin
>         #100 CLK = ~CLK; // 100ns翻转一次
>     end
> 
>     /* 第一位A的判断模块 */
>     integer A_Calc_Result = 0; // A的运算式计算结果
>     reg    A_Judge_Output = 0; // A的大小判断结果
>     // 组合逻辑部分
>     always @(Ques_Give_to_A_x, Ques_Give_to_A_y)
>     begin
>         #5 A_Calc_Result = Ques_Give_to_A_x + Ques_Give_to_A_y; // A只用5ns就能计算出结果
>     end
>     // 时序逻辑部分
>     always @(posedge CLK)
>     begin
>         if (A_Calc_Result < 10)
>             A_Judge_Output = 1;
>         else
>             A_Judge_Output = 0;
>     end
> 
>     /* 第二位B的判断模块 */
>     integer B_Calc_Result = 0; // B的运算式计算结果
>     reg    B_Judge_Output = 0; // B的大小判断结果
>     // 组合逻辑部分
>     always @(Ques_Give_to_B_x, Ques_Give_to_B_y)
>     begin
>         #50 B_Calc_Result = Ques_Give_to_B_x + Ques_Give_to_B_y; // B要50ns后才计算出结果
>     end
>     // 时序逻辑部分
>     always @(posedge CLK)
>     begin
>         if (B_Calc_Result < 10)
>             B_Judge_Output = 1;
>         else
>             B_Judge_Output = 0;
>     end
> 
>     // 还是那个吃瓜异或门
>     wire Answer_from_XOR_Gate; // 异或门输出
>     xor(Answer_from_XOR_Gate, A_Judge_Output, B_Judge_Output);
> 
>     // 淺真通过PAD给出题目，并接受A、B两位的答案
>     PAD Communicate_With_SuperSASS(
>             Ques_Give_to_A_x,
>             Ques_Give_to_A_y,
>             Ques_Give_to_B_x,
>             Ques_Give_to_B_y,
>             Answer_from_XOR_Gate
>         );
> endmodule
> ```
>
> ---
>
> 淺真不知情，认为她们还是那愚蠢的、只会瞬间给出结果的笨蛋们，于是直接给的原样测试。  
> *【但这个时候，无论改成什么测试数据都会输的啦，要乖乖陪她两位玩ff14哦，淺真大人w……*

让我们看看现在“地球”上的结果：  
![A、B那边的结果（时序逻辑）](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_01-14-18.png)  
完美了！`Answer_from_XOR_Gate`一直是`0`，即便一丁点的毛刺都没有！  
虽然`A`在$15\textrm{ns}$的时候就得到了计算式的结果，  
但现在她已经不是原来的她了，因为她结识到了新朋友`clk`，认识了“时间”，学会了等待，掌握了同步变化！  
等到$100\textrm{ns}$时，`B`无论如何都该算完了，因此这个时候两位们再一起判断，共同把判断结果给异或门，再由异或门把答案输出到PAD上。  
`clk`、`A`、`B`、`xor`，这四位少女们组成的轻锐小队，一定能把淺真魔王打得连连吃瘪！

不信？来看看淺真那边接收到的答案：  
![淺真那边发送的测试数据以及收到的答案（时序逻辑）](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_03-26-53.png)  
等了整整$200\textrm{nm}$，都没有收到一丁点错误答案。  
看来确实败了，败得很彻底。

因此欢呼吧！看来我们的天然呆们刚刚发现了“时序”！  
*【淺真可要哭了，要被发现玩龙骑天天躺地上喊999了xqwqqq……*

---

由此**总结一下**，可以看出时序逻辑电路的基本作用了：  
利用时序信号，使得电路各部分能够**同步地进行状态变换**，保持电路的稳定，  
同时还可以**规避**异步（组合逻辑部分）因时间差所造成的**毛刺**，反正就是**确保电路的稳定！**  
毕竟稳定才是电子器件第一要旨，因此时序逻辑电路可以说是数字电子能广泛应用的基本条件了。

*试想你会选择速度更快，但隔一秒钟就给你报错，隔一刻钟就给你蓝屏的组合逻辑电脑；*  
*还是虽然慢一点，但让你边玩游戏边渲染视频边下东西边跑代码边机器学习便挖矿连续几天一点问题没有的时序逻辑电脑？*  
其描述方法是用“**状态图**”，每个时钟周期（`clk`上升或下降沿）进行一次判定并转移状态，再根据状态（也可能还根据输入)得到相应的输出。

*【我觉得前面举的那么大段例子，效果还不如这一段总结好，有点呜呜了'_>'*……

### 4. 组合逻辑电路注意点

#### (1) reg类型相关

首先先说一个小点：  
在组合逻辑电路中，虽然有定义寄存器类型`reg`，  
但**综合出来的电路没有寄存器**`reg`，全是门级电路和连线。  
定义成`reg`只是为了满足**语法要求**：
> `alawys`中规定赋值都要用`reg`【不然用`wire`线网赋值怎么听都很怪x……

#### (2) 敏感信号相关

`always @(.../*)`里面的**敏感信号，可不能乱写**，  
其不要多，也不要少，**最好恰好等于**语句块内以下两种信号：

* 用作从外部输入的信号（内部已经赋值过的信号可以不用，但建议还是写上）
* 用作判断语句的信号

缺少这两个任意一种，都会收到这样一条警告：  
> Warning (10235): Verilog HDL Always Construct warning at `*`.v(`*`):  
> variable "`*`" **is read** inside the Always Construct **but isn't** in the Always Construct's **Event Control**

如果多了一个信号但没用到的话，会收到这样一条警告：  
> Warning (21074): Design contains 1 input pin(s) that **do not drive logic**  
> -> Warning (15610): **No output dependent on input** pin "`*`"

---

比如可能想设计这样一个模块：  
> 在一个使能信号`EN`**变化的瞬间**（包括从高变低和低变高两种），  
> 检测`a`的输入，并把它赋值给`b`。
>
> 其他时候无论`a`怎么变，`b`都不动。

如下面的波形图：  
![想要实现的功能波形图](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_15-33-52.png)  

首先可能写成这样的形式：

```v
module test_module(b, EN, a);
    output reg b;
    input EN, a;

    always @(EN)
    begin
        b = a;
    end
endmodule
```

根据检验真理的唯一标准——「在？看看"RTL"」：  
![第一种形式的RTL](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_14-54-55.png)  
傻了吧，就没`EN`什么事。  
*【不要再让我给波形图了，就跟RTL画的一样：`a`是什么`b`就输出什么，不信自己去试罢.jpg……*

第二种形式：

```v
module test_module(b, EN, a);
    output reg b;
    input EN, a;

    always @(a)
    begin
         if (EN)
            b = a;
          else
            b = b;
    end
endmodule
```

RTL：  
![第二种形式的RTL](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_15-01-18.png)  
傻了吧，成锁存器了。  
最后的波形也不满足上述要求（在EN为高电平时，`b`会一直随着`a`变）。

**所以：**  
以后在组合逻辑电路写敏感信号的时候，需要恰好把里面用到的信号写完整，  
不过`*`代表的就是`always`里所有用到的信号【所以以后统统写`always @(*)`就好啦√……  
*注：这是个人在目前的认识范围内总结的，不一定正确，所以各位有什么反例请务必向我说明！……*

> 其实上面的描述，所想实现的是一个“双边沿触发的触发器”。  
> 虽然不能直接用一个触发器实现（因为不存在双边沿触发的触发器），  
> 但如果一个不够，那就两个！
>
> ```v
> module Double_Edge_Triggered(b, EN, a);
>     output wire b;
>     input EN, a;
> 
>     assign b = (reg_pos & EN) | (reg_neg & (!EN)); // 意思是：如果EN高电平，就输出pos> 寄存器存的值；否则输出neg寄存器存的值。
> 
>     reg reg_pos, reg_neg;
>     // reg_pos - 上升沿触发
>     always @(posedge EN)
>     begin
>         reg_pos <= a;
>     end
> 
>     // reg_neg - 下降沿触发
>     always @(negedge EN)
>     begin
>         reg_neg <= a;
>     end
> endmodule
> ```
>
> ![上述代码RTL](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_15-42-18.png) ![上> 述代码波形图](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-28_15-36-29.png)

---

*需要确认：*

```verilog
reg EN_SAVE; // 不是稳定的时钟信号，是由控制单元发出的使能

always @(EN_SAVE) // 组合逻辑电路
    ...

always @(posedge EN_SAVE) // 伪·时序逻辑电路【？
    ...
```

## Quartus中仿真和ModelSim中仿真的区别

* Quartus更偏向实际电路。
* ModelSim更偏向理论。  
  其有严格的执行顺序安排（各种串行并行规定好了的），  
  甚至可以像gdb那样进行debug，设置断点单步执行。

也就是说这两个仿真的结果有可能有不同，  
甚至有时候ModelSim仿真感觉波形完全对了，拿到Quartus甚至编译都不通过。

有兴趣可以拿下面这个代码仿真：

```v
module test_module(
        input EN,
        input a,
        output reg c = 0,
        output reg b = 0
    );

    always @(a, b)
        c = a ^ b;

    always @(a, c)
        b = a ~^ c;
endmodule
```

testbench为：

```v
`timescale 1 ns/ 1 ns
module test_module();
    reg EN = 0;
    reg a = 0, b = 0, c = 0;

    always @(a, b)
    begin
        c = a ^ b;
    end

    always @(a, c)
    begin
        b = a ~^ c;
    end

    initial
    begin
        #10 EN = 1'b1;
        a = 1'b1;
    end
endmodule
```

## 「心中有电路，代码有电路」

[写 Verilog 如何做到心中有电路？](https://www.zhihu.com/question/429037239)

## 状态机

状态机作用：  
在一个连续复杂的事物对象中，抽取需要关注的若干离散的“稳态”（状态），以及之间相互转换的“信号”，从而**描述这个事物对象**。  
如人很复杂，但如果只抽象出来五个状态：正常、饿、困、又饿又困、自闭，之间的转换如下图：

```mermaid
stateDiagram
    正常 --> 正常 : 
    正常 --> 饿 : 不吃饭
    饿 --> 正常 : 吃饭
    饿 --> 饿 : 
    正常 --> 困 : 不睡觉
    困 --> 正常 : 睡觉
    困 --> 困 : 
    饿 --> 又饿又困 : 而且不睡觉
    困 --> 又饿又困 : 而且不吃饭
    又饿又困 --> 又饿又困 : 
    又饿又困 --> 饿 : 只睡了觉
    又饿又困 --> 困 : 只吃了饭
    又饿又困 --> 正常 : 吃好饭睡好觉
    又饿又困 --> 自闭 : 保持太久
    自闭 --> 自闭 : 
```

是不是拿到所有人身上一套，发现：诶，好像都可以这样来描述【x……

抽象出状态以及状态转移方式，只是能描述这个对象，  
但我们真正的目的，是**根据不同状态，输出特定的信号**。  
比如上面：当这个人到了“自闭状态后”，就会对手机发送信号：打开网易云。

所以状态机最主要的作用就是：对于某一些输出信号，可能有很复杂的条件，  
但条件可以划分成若干状态并转移，达到某一状态再输出该信号。  
则可以**用状态机来简化该输出方式**。

因此状态机作用只是**方便**表达，让代码看上去**更加清晰易懂**，  
特别是在流程复杂时，一般都很自然而然就想到用这种状态间的转换来实现的方式。  
即：其不是完成某一功能必要的方式，而是更好描述怎么实现该功能的**工具**。

如上面要输出“打开网易云”这一信号，完全可以就采用纯的`if`判断，  
`if (不吃饭&&不睡觉&&保持太久) then 打开网易云`，但肯定没考虑全会很复杂。

---

肯定讨论的都是有限状态机啦，这样我们才能去实现，  
状态机的**状态转移**，采用的是“**时序逻辑电路**”

分为“一段式”、“两段式”和“三段式”。

一般采用三段式有限状态机：

1. 状态寄存器
2. 状态组合逻辑电路（控制状态的转移）
3. 输出组合逻辑电路（控制操作的执行（命令的输出））

参考自[基于有限状态机的8位RISC CPU的Verilog实现](https://blog.csdn.net/icurious/article/details/86559931)。

## 错误记录

### 1. Warning (10240) - 因条件考虑不全产生锁存器(Latch)

> Warning (10240): Verilog HDL Always Construct warning at \*(16): inferring latch(es) for variable "\*", which holds its previous value in one or more paths through the always construct.

在FPGA开发中，**组合逻辑电路**部分，要尽量避免锁存器。

#### (1) 补充：什么是锁存器，其余触发器区别

可以大致理解为：都是**存储信息数据**的作用。

* 锁存器：用在组合逻辑电路，对**电平敏感**。
* 触发器：用在时序逻辑电路，对**边沿敏感**。

在组合逻辑电路（即没有时钟信号的电路），如果需要存储数据，则要用到锁存器；  
在时序逻辑电路中，用触发器完全代替了锁存器。

*因此在时序电路中，不会产生锁存器的问题。*

#### (2) 警告产生原因以及为什么避免Latch

首先理解组合逻辑电路（`always @(*)`语句块）目的：**给定一个输入，对应一种输出**。  
即输出和输入基本上是一种确定的关系，是**可以用真值表**，表达出输出和输入的关系的。  
一般来说**输入变动，输出也会跟着变动**，  
但如果出现锁存器(Latch)，就违背了这一常理，导致输入变动，输出可能保持之前的值(holds its previous value)。

自己有时**没有考虑所有的输入条件，某些条件下变量保持原来的值**，因此综合时要产生锁存器来可以让其保持原来的值，  
但自己并不想让它保持之前状态，只是单纯自己没考虑周全，  
从而会贴心地产生警告告诉你：是不是忘了`else`或`default`呀.jpg。

因此产生原因就显而易见了：`if`或者`case`中**没判断完所有的敏感变量情况**。  
在大量用`if`、`case`判断的模块中（说的就是你，状态机！），  
如果漏掉某个状态，就会产生这个警告。

那如果不避免Latch会导致什么呢？  
其一是可能跟自己想实现的逻辑偏离，可以看下面的例子：
> 例 - 买东西考虑自己是否有钱：
>
> 当想买东西时，根据自己是否有钱判断买不买：
>
> ```v
> reg 不买 = 0; // 默认是有钱man
> always @(想买东西)
> begin
>     if (没钱了)
>        不买 = 1;
> end
> ```
>
> 某一天没钱了，“不买”为改变为`1`，  
> 但后面如果有钱了，**“不买”会保持之前的状态还是`1`**，让其成为勤俭持节能手。
>
> 故应改为：
>
> ```v
> reg 不买;
> always @(想买东西)
> begin
>     if (没钱了)
>        不买 = 1;
>     else // 有钱
>        不买 = 0;
> end
> ```

其二是锁存器属于组合逻辑电路的，本身存在一些缺陷，不推荐使用（如其无法避免毛刺）。  
![D锁存器波形图](images/%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0--05-25_20-03-34.jpg)  
输入信号D有一段毛刺（蓝圈所示），此时若使能E有效，会把这段毛刺也记录进来。  
*但除非改为时序逻辑电路，否则这个问题无法避免。*

#### (3) 一定要处理这个警告（即一定要避免锁存器）吗

但！**并不是要完全拒绝锁存器**，有时候**可能就是要用锁存器**，自己就是想让它保持之前的值。  
比如用一个`flag`记录之前的状态，以决定后面的行为，就必须要用锁存器。

比如我们都知道：时序电路会导致延时，输入要慢一个节拍才能存进去，  
如果要实现一个“即时响应输入数据的寄存器”：

```v
output reg [7:0] data_out;
input reg [7:0] data_in;
input reg EN_save; // 存储使能 - 高电平时立刻存储输入的数据并输出；低电平时输出原数据

always @(EN_save, data_in) // 当存储使能变化，或输入过来的数据变化时进行响应
    if (EN_save)
        data_out = data_in;  // 更新输出为输入数据
    else
        data_out = data_out; // 保持原有输出
```

*其实这就是一个锁存器了。*

因此不要强行将锁存器消去，根据自己实际需求决定。

#### 修改方法1 - 改为时序逻辑电路（伪的也可以）

上面说到，时序电路会将“存储数据”这个功能用触发器实现，  
改成时序逻辑电路就直接避免这个问题啦。

~~所谓伪的，就是明明不是时钟信号，但用`posedge`取用，~~  
~~这个时候`always @(posedge EN_WT)`和`always @(EN_WT)`一样。~~  
*不一定正确，需验证。*

如下面这段：

```verilog
// 控制信号：
// EN_RD    - 读出信号 (AX→IB)
// EN_WT    - 写入信号 (AXin)
module Register_Rx(D_OUT_LED, D_OUT, RST_N, EN_RD, EN_WT, D_IN);
    output wire [7:0] D_OUT_LED; // D_OUT_LED恒输出Rx，用来给LED显示
    output reg [7:0] D_OUT;
    input RST_N;
    input EN_RD, EN_WT;
    input [7:0] D_IN;

    reg [7:0] Rx = 0;
    assign D_OUT_LED = Rx;

    always @(*) // 因为有时候EN_WT但D_IN还要晚一点；所以这里只能*而不能是posedge EN_RD/WT
    begin
        if (!RST_N)
        begin
            Rx <= 0;
            D_OUT <= 0;
        end
        else
        begin
            if (EN_WT) // 写入操作
                Rx = D_IN;
            else
                Rx = Rx;
            if (EN_RD) // 读出操作
                D_OUT = Rx;
            else
                D_OUT = 0;
        end
    end
endmodule
```

改为：

```verilog
// 控制信号：
// EN_RD    - 读出信号 (AX→IB)
// EN_WT    - 写入信号 (AXin)
module Register_Rx(D_OUT_LED, D_OUT, RST_N, EN_RD, EN_WT, D_IN);
    output wire [7:0] D_OUT_LED; // D_OUT_LED恒输出Rx，用来给LED显示
    output reg [7:0] D_OUT;
    input RST_N;
    input EN_RD, EN_WT;
    input [7:0] D_IN;

    reg [7:0] Rx = 0;
    assign D_OUT_LED = Rx;

    // Rx
    always @(posedge EN_WT, negedge RST_N) // 【这里因为EN_WT并不是真正的时钟信号，所以可能是伪的
    begin
        if (!RST_N)
            Rx <= 0;
        else
            if (EN_WT) // 写入操作
                Rx = D_IN;
            else
                Rx = Rx;
    end

    // D_OUT
    always @(posedge EN_RD, negedge RST_N)
    begin
        if (!RST_N)
            D_OUT <= 0;
        else
            if (EN_RD) // 读出操作
                D_OUT = Rx;
            else
                D_OUT = 0;
    end
endmodule
```

#### 修改方法2 - 将组合逻辑分离成组合和时序逻辑

虽然可以利用锁存器，时间组合逻辑电路上的“存储”功能，  
但其也是完全可以转换成触发器的【对想消掉所有能消的Warning的强迫症也是有方法的w……

就比如在有关数电的实验上，用到了自循环状态机（个人取的名字，指如果不加控制，会一直在状态间转移停不下来），并且是两或三段式的（分离出了“状态组合逻辑电路”）。  
在如模拟CPU执行指令的时候，现实中确实是直接哗哗地就把指令执行完了，最后可能停在如`STOP`指令展示结果，
但如果想在实验中观测中间的运行现象，很常见的想法就是：
> 加一个使能`RUN`，只有该使能有效才开始状态转移。

但光加一个使能还不够，因为按键按下弹起这一间隔中，因为频率很快，可能已经执行了很多个指令了。  
所以还要加一个`flag`，标记执行了一条指令，当`flag=1`后，即使`RUN`也不再执行。  
很容易写出以下形式：

```v
// FSM #2 - 状态组合逻辑电路（控制状态的转移）
reg have_Run = 0; // flag，在模拟时用RUN_N限制每次只进行一条指令操作
                  // 该flag表示该RUN_N下已经执行了一指令
always @(*)
begin
    case (State)
        INIT:
        begin
            if (RUN_N) // 如果RUN_N不再为有效电平，要把flag复原，否则**保持原状态**
                have_Run = 0;
            else
                have_Run = have_Run;
            if (!RUN_N && !have_Run) // 如果RUN_N为有效电平，且没RUN过，则开始状态转移
            begin
                have_Run = 1;
                next_State = STATE_1;
            end
            else
            begin
                have_Run = have_Run;
                next_State = INIT;
            end
        end
        STATE_1:
            next_State = ...
        STATE_2:
            next_State = ...
        ...
        default: 
            next_State = INIT;
    endcase
end
```

因为有`have_Run = have_Run;`，且在组合逻辑电路中，自然会Warning，  
消除方法，则可将`have_Run = next_have_Run`，然后在一个时序电路中控制`next_have_Run`，  
如下：

```v
reg have_Run = 0; // 在模拟时用Run限制每次只进行一条指令操作，
                  // 该位flag表示该RUN下已经执行过一条指令
reg have_Run_last; // have_Run的上一状态，由时序控制状态的转移。
always @(posedge CLK, negedge RST_N) // 完全可以不加异步复位，直接have_run_last <= 0/...
begin
    if (!RST_N)
        have_Run_last <= 0;
    else
        have_Run_last <= have_Run;
end

// FSM #2 - 状态组合逻辑电路（控制状态的转移）
always @(*)
begin
    have_Run = have_Run_last; // 先要在case外这样说，才能避免直接赋值为原状态
                              // 不然case每个条件都要赋值have_Run
                              //   否则就是没考虑到会保持原状态出现Latch
    case (State)
        INIT:
        begin
            if (RUN_N)
                have_Run = 0;
            if (!RUN_N && !have_Run)
            begin
                have_Run = 1;
                next_State = ST_0;
            end
            else
                next_State = INIT;
        end
    STATE_1:
        next_State = ...
    STATE_2:
        next_State = ...
    ...
    default: 
        next_State = INIT;
    endcase
end
```

参考自[关于锁存器问题的讨论](https://zhuanlan.zhihu.com/p/109952414)和[【FPGA】Verilog中锁存器（Latch）原理、危害及避免](https://blog.csdn.net/ARM_qiao/article/details/124309796)

## 总线相关

连接到总线，输出端必须加三态门。  
verilog模拟如下：

```verilog
assign D_OUT = EN_RD ? data : 8'bZ;
```

`EN_RD`为输出使能。

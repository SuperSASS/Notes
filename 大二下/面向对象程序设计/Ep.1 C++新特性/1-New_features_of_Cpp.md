# Ep.1 C++新特性

## 一、命名空间

## 二、字符串

* `s = cin.get();` - 只接收一个字符，等同于`getchar`。
* `cin.get(s,n)` - 对字符串s读取长度为n的字符串。
* `cin.getline(s,n)`

## 三、初始化

```c++
int a = 3; //Init of C
int b(3); //Init of C++
```

## 四、引用

普通变量的引用：

```c++
int &a  = b;
```

注意：

* 引用并没有开辟新的空间，与被引用变量都是同一个变量，共用空间。
* 引用后，该变量不能再引用其他变量。

---

指针引用：

```c++
int a = 10,
    *p = &a;
    *&pp = p;
```

也就是指针的别名。

---

函数返回值引用：

```c++
int n; // Global Varible
int & setValue() { return n; }
int main()
{
    setValue() = 40; //n = 40;
}
```

此时函数返回值相当于个变量。

---

注意`enum`枚举类型是不能直接`cin>>`的，  
可以变为`cin >> (int&)a`即可读入。

## 五、const

新内容：`const`与指针 - 常量指针与指针常量

```c++
int n, m;
const int* p1 = &n; //常量指针
                    //const管的是*p1，*p1不能赋值。
                    //不能通过*p1来改n的值，只读。
p1 = &m; //允许
int* const p2 = &m; //指针常量
                    //const管的是p2，p2不能赋值。
*p2 = 5; //允许
```

只需记住：`const`紧接的部分不能被修改。

常量指针注意事项：

1. 不能把常量指针赋值给非常量指针，反过来可以

   ```c++
   const int* p1 = &a;
   int* p2 = &b;
   p2 = p1; //非常量指针<-常量指针，错误
   ```

---

常引用 - `const int &a`。

同样，不能吧常引用赋值给普通引用。

## 六、函数重载

即：同一个函数，针对不同参数，适配多种功能。

```c++
int max(int a, int b);
double max(double a, double b);
```

*而在C中，是不允许有同样的函数名的。*

注意：

* 不允许引起二义性（存在多个函数均满足）。

  ```c++
  max(3,2.4); //错误，两个均可（如果只有一个是对的，会强制类型转换）
  ```

* 只能是参数的不同，不能是相同参数不同的返回值。

## 七、带默认参数的函数

可以给函数的参数加上初始值。

注意：

1. 只能从**最右侧**开始依次赋初值。

   ```c++
   int f(int a, int b=1, int c=2);
   int err(int a, int b=1, int c, int d=2); //错误
   
   f(1);   //b,c用初值
   f(1,2); //c用初值
   f(1,2,3);
   ```

2. 只能在原型声明或定义，两者中选一个给定初值。

   ```c++
   int f(int a, int b=1); //原型声明赋初值

   int f(int a, int b) { return a+b; } //定义中不能赋初值
   ```

3. 在函数重载中可能会引起二义性

   ```c++
   void f() {}
   int f(int x=5) {} //错误：调用f()时，会二义。
   ```

## 八、内联函数 - inline

为了减少函数调用时，分配参数的内存等操作的开销，引入了内联函数。  
作用是**在编译时**，将函数的代码直接插入到代码调用处，因此不会产生函数调用时的操作。

类似于**宏定义**，  
但相比于宏定义，会进行常规类型检查。

要求所内联的函数逻辑简单，一般不超过5行，且不含递归、循环之类的功能。  
否则即使加上`inline`，编辑器也不会替换。

## 九、内存管理 - new&delete

C++中，内存分为5个区，分别为：

* 栈区：由编辑器在需要的时候分配，通常是**局部变量、函数参数**等。
* 堆区：**由`new`分配**的内存块，释放不由编辑器管理，需要**手动释放**。
* 全局区(静态存储区)：**全局变量**和**静态`static`变量**存放的区域。
* 文字常量区：存放**常量**的区域。
* 程序代码区：存放**函数**的区域。

> 区别 - 堆与栈：
>
> 都是同样的先进后出的数据结构，经常统称为堆栈。  
> 但：栈是从上向下填充，堆是从下向上填充。

注意对于**指针变量**，其仍为一个局部变量，  
**存放在栈区**。

> 如：
>
> ```c++
> int *p = new int(4);
> delete p;
> ```
>
> 刚`new`时：此时`p`为一个指针变量，**存放在栈区**，  
> **指向为堆区**的一个地址空间，其存放的值为$4$。
>
> 当`delete`后，**只是删除了堆中**的值为$4$的地址空间，并**删除**了指针变量的**指向**。  
> 而栈区的`p`会随着程序终止而被系统回收。

对于多维数组的申请、数组的释放：

```c++
//Create
int (*p)[10] = new int[5][10];
p = p + 2; //此时为p[0][0]→p[2][0]

int (*p2)[3][4] = new int[5][3][4];
p2 = p2 + 2; //此时为p2[0][0][0]→p2[2][0][0]

//Destory
delete[] p;
delete[] p2;
```

> 区别 - `new/delet`与`malloc/free`的使用注意：
>
> * 使用`free`释放`new`申请的空间，可能因为无法调用析构函数`~()`而出错。
> * 使用`delete`释放`malloc`申请的空间，虽然不会有问题，但可读性很差。

## 十、异常处理 - try&throw&catch

对于运行时出错RE，  
可以使用异常处理捕捉出错信息。

异常处理可以达成以下目标：

* 让程序不是简单终止。
* 可以知道哪段代码出现异常。
* 保存之前所执行任务的信息。

C++中由3个部分组成异常处理机制：

* `try` - 检查  
  将需要检查的语句块放在`try {}`中。
* `throw` - 抛出  
  用来在出现异常时抛出异常信息。
* `catch` - 捕捉  
  根据异常信息类型捕捉异常信息，并按照异常类型来相应处理。

```c++
int main()
{
   try
   {
      int reStatus = myFunc();
      if (reStatus == ...) throw x; //x可以是常量，也可以是变量
   }
   //在try后紧跟若干个catch
   catch(int x) { ... } //若throw的为整形，则执行这个代码块
   catch(char s) { ... } //若为字符型，则执行这个代码块
   catch(...) { ... } //注意这里的catch...是真实存在的，代表任意类型均匹配。
   //若已经执行了一个catch，则跳过其余catch，并继续执行后续代码
   otherFunc();
}
```

注意事项：

1. `try`与`catch`必须一起紧邻出现，中间不能有其他语句。  
   可以只有`try`没有`catch`，反之不行。  
   如果没有发生异常(没有`throw`)，则`catch`均不执行。
2. `try`和`catch`即使检查语句块只有一条语句，也要用`{}`。
3. `throw`抛出异常后，首先在本层函数检查`catch`，  
   * 若匹配成功，则直接处理，并不再往上一层函数抛出异常。
   * 若没有匹配的，则**跳到上一层函数**（父函数），抛出相同异常并检查`catch`，  
     一直跳到找到`catch`或者跳到根函数(`main`)。
4. 进行异常处理后，程序不会自动终止，而是继续执行`catch`后的语句。
5. `catch()`只检查类型，不检查值。
6. 删节号`...`代表所有类型的异常。
7. 若没有找到相应`catch()`，则终止程序。

*一般在调用其他未知函数的时候，加个`try`检查一下。*

---

C++中存在一些标准的异常类型，  
此时在`try`中，即便没有`throw`，  
但发生标准异常时会自动抛出，并可以被`catch`。

```c++
string str;
int i = 0;
bool a = 1;
cin >> str;
try
{
   while (a == 1)
      str.at(i++);
}
catch(out_of_range err) { cout<<err.what(); }
//其中 out_of_range 类型为标准异常，是一个类，代表越界
otherFunc();
```
# 第三节 对象指针相关

## 一、相关概念

### 1. 作用域

1. 函数作用域
2. 块作用域  
   `{}`
3. 类作用域
4. 命名空间作用域
   1. 空间中直接访问
   2. 空间外用`::`。

### 2. 对象的生命周期

任何变量都有创建和消失的时候，这一段时间称为对象的生命周期。

1. 静态生命周期  
   对于部分变量，其生命周期跟程序运行周期相同，称为“静态生命周期”。  
   如：
   1. 所采用的命名空间中的对象。
   2. 全局变量
   3. 函数中静态局部变量`static`。
2. 动态生命周期  
   从对象创建开始，结束于声明所在块执行完毕。

### 3. 数据共享

针对面向过程的编程中，要实现**不同函数**的数据共享，采用**全局变量**即可。  
针对面向对象的编程中，要实现**同一类不同实例**的数据共享，则采用**静态成员**。

## 二、类的静态成员

一旦将某成员变为静态，则会不依赖于任何实例。  
只是只能通过类来访问静态成员。

而静态成员也必须对应于某个实例，才能访问其动态成员。

### 1. 静态数据成员

> 定义 - 类的静态数据成员
>
> 以`static`关键字来声明，能够让这个类的**所有对象共同维护、使用**这个静态数据成员，  
> 从而实现同一类的不同对象之间的数据共享，为静态生命周期。

⚠：静态数据成员，**必须初始化**，且**必须在类外初始化**。

```c++
class MyClass
{
  static int count; // 不能写为 static int count = 1; 否则报错
}
int MyClass::count = 1; //必须要这样初始化！！
```

### 2. 静态成员函数

将函数变为静态，因此**不依赖于任何实例**，  
因此**只能访问静态成员**。

在类外使用时，也跟静态数据一样，用`ClassName::StaticFunc();`。

> 虽然非静态函数也能访问静态数据成员，看起来静态函数没什么用，  
> 但静态函数限定了只能操作静态成员，可以起到一个隔离的作用。  
> 同时在不生成类的实例时，非静态函数不能调用，而静态函数可以。
>
> 总之，从OOA/OOD的角度考虑：  
> 一切**不需要实例化就可以有确定行为方式**的函数，都应该设计成静态的。

但如果要访问动态成员，则必须传递某个实例。

```c++
class MyClass
{
  static int st;
  int dy;
public:
  static void print(const MyClass &c)
  {
    cout<<st<<endl;
    cout<<c.dy<<endl; //错误方式：cout<<dy<<endl;
  }
};
int MyClass::st = 1;

int main()
{
  MyClass A;
  MyClass::print(A); //必须传递个实例化的类
}
```

## 三、几个类的常量

### 1. 常对象

```c++
const MyClass c1(1,2);
```

⚠必须进行**初始化**。

跟常量差不多。

### 2. 常函数成员

作用：**绝对不能**对属于的对象进行**修改**（主要是不能修改数据成员，但普通函数成员有可能修改数据成员，所以与不能调用普通函数成员）。  
主要作为一个返回数据成员的作用（如C#中的`get`）。

对于常对象，**只能**使用类中的**常成员函数**，不能调用普通成员函数，  
即常成员函数是常对象唯一的接口。

声明方式：

```c++
class MyClass
{
  int func1(...) const
  {
  }
};
```

与普通成员函数**可以同名**，属于重载的关系，  
在只有“常成员函数”时，普通对象也可以调用常成员函数，只不过不能修改类中内容；常对象不能调用该函数，  
当重载时，普通对象调用普通函数；常对象调用常函数。

> 拓展 - 能重载的原因：
>
> ![图 1](images/2.3-Class%26Object_3--04-23_20-36-12.png)  
> 每个成员函数都会隐含传递一个`*this`指针，指向正在操作的对象实例，  
> 可以看到常成员函数与普通成员函数参数有区别，所以重载。
>
> 注：`CTest *const this`代表**指针常量**，是`this`不能修改为别的地址；与**常量指针**`const CTest *this`(或`CTest const *this`)区别，是`*this`不能修改其内容；而`const CTest *const this`是常量指针常量；两个都不能改。
>
> 补充：对于上面的静态成员函数，则没有`*this`指针（但不能与普通成员函数重载哦）。

### 3. 常数据成员

类中不能变（即常量）的数据成员。  
必须在初始化列表里初始化。  
一个类的不同对象，可以拥有不同值得某一常数据成员（只要在初始化给不同值就可以）。

```c++
class MyClass{
  const int a;
  MyClass(int _a) : a(_a) {}
}

int main()
{
  MyClass c1(100), c2(200);
}
```

### 4. 常引用成员

```c++
class c
{
  const int &a;
}
```

常引用并非只属于类的概念，其是指引用对象不能更改值，保证引用不用新建变量的高效率同时防止被误操作更改值。

要用常成员初始化常引用。

## 四、友元函数

使得非`public`成员也能在不同类之间公开。  
分为三类：

1. 友元函数
2. 友元类
3. 友元成员函数

### 1. 友元函数

在类内声明中由关键字`friend`修饰的**非成员函数**。

注：非成员函数即是在类外的**普通函数**。  

如：在类外的`int myFunc(...) {}`是普通函数，  
而`int myClass::myFunc() {}`是类外定义的成员函数。

此时可以**像成员函数一样**，访问私有成员。  
相当于给外部函数开个权限。

### 2. 友元类

一个类$A$可以作为另一个类$B$的友元类，  
此时$A$中任意成员函数都是另一个类$B$的友元函数，可以访问任意成员。

但**友元关系是单向**的。

```c++
class ClassB
{
private:
  int x;
  friend class ClassA; //此时A的成员函数可以任意使用B的成员
                  //但注意B不能访问A的
};

class ClassA
{
private:
  ClassB b;
public:
  void set(int _x);
}

void ClassA::set(int _x)
{
  b.x=_x; //即便是ClassB,也不能在类外访问x；但ClassA可以。
}
```

## 五、对象关系

### 1. 聚合/组合 - 封闭类

一个类的对象是另一个类的成员，包含成员对象的类叫封闭类(Enclosing),  
这种关系表征了整体和部分关系，是一种"has-a"关系。

即将若干个部分类封闭成一个整体类。

```c++
class Point()
{
  ...
}

class Line() //Encloseing
{
  Point p1,p2;
}
```

---

需要注意封闭类的构造函数，要满足被封闭的部分类的构造函数。

构造析构顺序：  

* 构造时
  * 先执行成员对象的构造函数。  
    构造时只与在类中的**声明顺序一致**，与初始化列表中出现顺序无关。
  * 再执行封闭类的构造函数。
* 析构时
  * 先析构封闭类。
  * 再封闭成员对象。

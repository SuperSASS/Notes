# 第三节 对象指针相关

## 一、相关概念

### 1. 作用域

1. 函数作用域
2. 块作用域  
   `{}`
3. 类作用域
4. 命名空间作用域
   1. 空间中直接访问
   2. 空间外用`::`。

### 2. 对象的生命周期

任何变量都有创建和消失的时候，这一段时间称为对象的生命周期。

1. 静态生命周期
   对于部分变量，其生命周期跟程序运行周期相同，称为“静态生命周期”。  
   如：
   1. 所采用的命名空间中的对象。
   2. 全局变量
   3. 函数中静态局部变量`static`。
2. 动态生命周期  
   从对象创建开始，结束于声明所在块执行完毕。

### 3. 数据共享

针对面向过程的编程中，要实现**不同函数**的数据共享，采用**全局变量**即可。  
针对面向对象的编程中，要实现**同一类不同实例**的数据共享，则采用**静态成员**。

## 二、类的静态成员

一旦将某成员变为静态，则会不依赖于任何实例。  
只是只能通过类来访问静态成员。

而静态成员也必须对应于某个实例，才能访问其动态成员。

### 1. 静态数据成员

> 定义 - 类的静态数据成员
>
> 以`static`关键字来声明，能够让这个类的所有对象共同维护、使用这个静态数据成员，  
> 从而实现同一类的不同对象之间的数据共享，为静态生命周期。

```c++
class MyClass
{
  static int count = 0; //不带初值默认为0（但不同编译器可能不同）
}
```

### 2. 静态成员函数

将函数变为静态，因此**不依赖于任何实例**，  
可以**直接访问**静态成员。

在类外使用是，也跟静态数据一样用`ClassName::StaticFunc();`。

但如果要访问动态成员，则必须传递某个实例。

## 三、几个类的常量

### 1. 常对象

```c++
const MyClass c1(1,2);
```

必须进行**初始化**。

### 2. 常函数成员

```c++
class MyClass
{
  int func1(...) const
  {
  }
};
```

### 3. 常数据成员

### 4. 常引用

要用常成员初始化常引用。

## 四、友元函数

使得非`public`成员也能在不同类之间公开。  
分为三类：

1. 友元函数
2. 友元类
3. 友元成员函数

### 1. 友元函数

在类内声明中由关键字`friend`修饰的**非成员函数**。

注：非成员函数即是在类外直接声明的普通函数。  
如：`int myFunc(...) {}`，而`int myClass::myFunc() {}`是类外定义的成员函数。

此时可以**像成员函数一样**，访问私有成员。

### 2. 友元类

一个类$A$可以作为另一个类$B$的友元类，  
此时$A$中任意成员函数都是另一个类$B$的友元函数，可以访问任意成员。

但**友元关系是单向**的。

```c++
class ClassB
{
private:
  int x;
  friend class ClassA; //此时A的成员函数可以任意使用B的成员
                  //但注意B不能访问A的
};

class ClassA
{
private:
  ClassB b;
public:
  void set(int _x);
}

void ClassA::set(int _x)
{
  b.x=_x; //即便是ClassB,也不能在类外访问x；但ClassA可以。
}
```

## 五、对象关系

### 1. 聚合/组合 - 封闭类

一个类的对象是另一个类的成员，包含成员对象的类叫封闭类(Enclosing),  
这种关系表征了整体和部分关系，是一种"has-a"关系。

即将若干个部分类封闭成一个整体类。

```c++
class Point()
{
  ...
}

class Line() //Encloseing
{
  Point p1,p2;
}
```

---

需要注意封闭类的构造函数，要满足被封闭的部分类的构造函数。

构造析构顺序：  

* 构造时
  * 先执行成员对象的构造函数。  
    构造时只与在类中的声明顺序一致，与初始化列表中出现顺序无关。
  * 再执行封闭类的构造函数。
* 析构时
  * 先析构封闭类。
  * 再封闭成员对象。

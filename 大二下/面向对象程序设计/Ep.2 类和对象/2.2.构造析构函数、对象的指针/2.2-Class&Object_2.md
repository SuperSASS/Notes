# 第二节 构造函数与析构函数

* 对象的**构造**过程：在**声明对象**的时候进行的**数据成员赋值**，称为对象的初始化。
* 对象的析构过程：

## 一、构造函数

### 1. 三种构造函数

> 定义 - 构造函数
>
> C++对象的初始化程序。

作用：构造函数的作用是在对象被创建时**利用特定的值构造对象**，将对象初始化为一个特定的状态，使一个对象**具有区别于另一个对象的特征**。

在对象被创建的时候由**系统自动调用**。

构造函数也是类的一个成员函数，具有一般成员函数的特征。  
其区别为：

* 函数名必须与类名相同，而且没有返回值。
* 在声明对象时由系统自动调用。

分为三类：

1. 默认构造函数：没有参数。
2. 带参数的构造函数：允许对象在被定义的时候，同时利用给定参数进行初始化
3. **复制（拷贝）构造函数**：参数就是该class对象的**引用**（⚠必须是引用）。  
   即使用已经存在的对象，去初始化同类的新对象。  
   > 解释 - 为什么复制构造函数必须是引用：
   >
   > 如果不是引用，调用复制构造函数的时候，需要先把实参拷贝到形参中，  
   但拷贝又要调用复制构造函数，搁这递归直接爆栈。

   ```c++
   class myClass
   {
      myClass(const myClass &a) { ...; }
   }
   ```

   当某个函数的**形参是类**，或者其**返回值是类（注意：不同编译器不一定支持）**，  
   则在调用该函数时，会调用“复制构造函数”。

   ```c++
   myClass myFunc(myClass A) { return A; }  // 形参是类、返回值是类
   
   int main()
   {
       myClass class1, class2;
       myFunc(class1); // 会先创建个形参A，然后调用A.myClass(class1);
   }
   ```

   > 拓展 - 对于函数返回值为一个类(如`MyClass`类)的情况(MinGW64)：
   >
   > 此时函数的返回值，会是该类的一个**临时对象**（实例），暂称为`tmp`。  
   > 返回的时候如果是该类的一个对象`a`，则会调用复制构造函数，即`tmp.MyClass(a);`，  
   > 退出返回后，在利用完毕（如赋值给其他变量、甚至什么都不做），则会**调用析构函数**。
   >
   > 如果在此时没有`return`语句，返回的是一个不确定的对象（这个对象甚至没有调用任何构造函数，应该是内存的脏数据），  
   > 然后也会调用析构函数。
   > ![图 1](images/2.2-Class%26Object_2--09-27_17-19-45.png)
   >
   > ![图 2](images/2.2-Class%26Object_2--09-27_17-32-15.png)  
   > 该图可以看出对于参数和返回值，都调用了复制构造函数。

即便自己没有定义任何显示构造函数，  
**系统**也会**隐式的创造一个**，不用不执行任何操作。  
约等于：`myClass() {}`。

但如果已经定义了一个构造函数，  
则严格按照所定义的构造。  
因此如果未定义默认（无参）构造函数，则无法直接创建对象`myClass A;`。

---

形如`myClass(...) : x(_x), ... {}`的形式，称为“初始化列表”。  
注意⚠：对于**常成员**`const`，以及**引用成员**`int &A`，**必须用初始化列表的方式**。

*【其他自己也都会，摸了*……

---

补充 - 调用构造函数方式：

```c++
class MyClass
{
  MyClass(int a) {}
};
int main()
{
  MyClass A(3);
  MyClass A = MyClass(3);
  MyClass A = 3; // ⚠特别注意，对于这里调用的也是构造函数，而非使用的重载运算符=！
}
```

## 二、析构函数

作用：与构造函数几乎正好相反，析构函数用于完成对象被删除前的清理工作。  
是在**对象的生存期即将结束**时由系统自动调用。

不显示定义，会默认生成析构函数。

注意：不能有参数。

## 三、对象指针相关

### 1. 对象指针

就是普通指向类变量的指针。

```c++
myClass my;
myClass *p  = &my;
```

### 2. this指针

* `this`指针是一个**隐含**于每一个**成员函数**中的特殊指针。  
  它是一个**指向**正在被该成员函数操作的**对象**，也就是要操作该成员函数的对象。
* 一个对象的`this`指针不是对象的一部分，不占用空间，不影响`sizeof()`。
* `this`作用域是在类内部，  
  当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，  
  **编译器**会自动将对象本身的地址**作为一个隐含参数**传递给函数。

  ```c++
  class MyClass
  {
    int x, y;
    voif func(int i, int j) { x=i, y=j; };
    //在编译器看来应该是：
    //void func(int i, int j, MyClass* const this) {this->x=i, this->y=j};
  }
  ```

一般情况成员函数的变量里不用加，因为编译器自动会加上`this`指针。  
但如果需要返回对象本身的地址时，则可以显示使用`return this`。

注意：静态成员函数`static`不能用`this`指针（因为它属于整个类，而不是某个具体对象）。

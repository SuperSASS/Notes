# 第二节 构造函数与析构函数

* 对象的**构造**过程：在**声明对象**的时候进行的**数据成员赋值**，称为对象的初始化。
* 对象的析构过程：

## 一、构造函数

> 定义 - 构造函数
>
> C++对象的初始化程序。

作用：构造函数的作用是在对象被创建时**利用特定的值构造对象**，将对象初始化为一个特定的状态，使一个对象**具有区别于另一个对象的特征**。

在对象被创建的时候由**系统自动调用**。

构造函数也是类的一个成员函数，具有一般成员函数的特征。  
其区别为：

* 函数名必须与类名相同，而且没有返回值。
* 在声明对象时由系统自动调用。

分为三类：

1. 默认构造函数：没有参数。
2. 带参数的构造函数：允许对象在被定义的时候，同时利用给定参数进行初始化
3. **复制构造函数**：参数就是该class对象的引用。  
   即使用已经存在的对象，去初始化同类的新对象。

   ```c++
   class myClass
   {
      myClass(const myClass &a) { ...; }
   }
   ```

   当某个函数的形参是类，或者其**返回值是类（注意：仅支持VC++）**，  
   则在调用该函数时，会调用“复制构造函数”。

   以及创建临时变量`myClass()`用于对其他对象赋值、作返回值、传值、初始化时，  
   会调用复制构造函数。
   **注意：仅支持VC++。**

   ```c++
   myClass myFunc(myClass A) {} 
   
   int main()
   {
       myClass class1;
       myFunc(class2); //会先创建个形参A，然后调用A.myClass(class1);
   }
   ```

即便自己没有定义任何显示构造函数，  
**系统**也会**隐式的创造一个**，不用不执行任何操作。  
约等于：`myClass() {}`。

但如果已经定义了一个构造函数，  
则严格按照所定义的构造。  
因此如果未定义默认（无参）构造函数，则无法直接创建对象`myClass A;`。

---

形如`myClass(...) : x(_x), ... {}`的形式，称为“初始化列表”。  
注意⚠：对于**常成员**`const`，以及**引用成员**，**必须用初始化列表的方式**。

*【其他自己也都会，摸了*……

## 二、析构函数

作用：与构造函数几乎正好相反，析构函数用于完成对象被删除前的清理工作。  
是在**对象的生存期即将结束**时由系统自动调用。

不显示定义，会默认生成析构函数。

注意：不能有参数。

## 三、对象指针相关

### 1. 对象指针

就是普通指向类变量的指针。

```c++
myClass my;
myClass *p  = &my;
```

### 2. this指针

* `this`指针是一个**隐含**于每一个**成员函数**中的特殊指针。  
  它是一个**指向**正在被该成员函数操作的**对象**，也就是要操作该成员函数的对象。
* 一个对象的`this`指针不是对象的一部分，不占用空间，不影响`sizeof()`。
* `this`作用域是在类内部，  
  当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，  
  **编译器**会自动将对象本身的地址**作为一个隐含参数**传递给函数。

  ```c++
  class MyClass
  {
    int x, y;
    voif func(int i, int j) { x=i, y=j; };
    //在编译器看来应该是：
    //void func(int i, int j, MyClass* const this) {this->x=i, this->y=j};
  }
  ```

一般情况成员函数的变量里不用加，因为编译器自动会加上`this`指针。  
但如果需要返回对象本身的地址时，则可以显示使用`return this`。

注意：静态成员函数`static`不能用`this`指针（因为它属于整个类，而不是某个具体对象）。

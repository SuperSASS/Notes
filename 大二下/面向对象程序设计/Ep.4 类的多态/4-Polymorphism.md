# Ep.4 类的多态

C++是通过“向对象**发送消息**”来处理对象的，  
每个对象根据所接收到的消息，来决定需要采取的行动，  
从而响应这个消息。

响应这些消息的是一系列的方法，  
方法是在类定义中，使用函数来定义的，  
因此C++是是用一种类似于函数调用的机制，把消息发送到一个对象上。

多态有两种理解：

* 相同对象受到不同消息。
* 相同消息被不同类型的对象接受。

一般指第二种。

根据在哪个阶段的多态，也分为两种：

* 编译时的多态
* 运行时的多态

## 一、静态多态

指的是在编译的时候就能知道所有方法调用的是哪些函数，  
是能在**编译的时候就确定**。

静态多态的分类：

* 函数多态
  * 普通函数的重载
  * 类的成员函数的重载
  * 运算符重载
* 宏多态
* 模板多态
  * 使用“类模板”

### 1. 函数多态

即对同名函数，采用不同的参数值，可实现重载，从而达到多态。  
如之前所学的“构造函数重载”。

### 2. 宏多态

```c++
#define _ADD(A,B) (A)+(B)
```

因为宏直接将内容替换，因此也可以适应不同类型的数据，  
带变量的宏多态可实现一种初级形式的静态多态。

### 3. 模板多态

如`sort()`的参数`cmp()`，  
根据不同的`cmp()`执行不同的方法。

## 二、动态多态

### 1. 实现

* 联编（绑定）  
  将函数体和函数调用关联起来。  
  在面向对象中：消息与对象的方法相结合。
  * 静态联编：联编在**编译连接阶段**完成。  
    通过用户制定调用的成员函数。在编译时根据类对象，来确定调用该成员函数的方法。
  * 动态联编：联编工作在程序运行完成的情况。  
    需要将成员函数声明为“虚函数”，然后再用基类的指针指向他。

## 三、多态实现规则

### 1. 赋值兼容规则

* 向上兼容性  
  基类赋值给派生类。
* 向下兼容性  
  派生类赋值给基类。必须显式转换，会丢失数据。

定义基类类型指针，指向派生类对象。

```c++
class A;
A a;
B b;
A* pa = &b;

pa
.stu()
```

需要基类对象的任何地方，都可以使用公有派生类的对象来代替。  
代替之后，派生类对象就可以作为基类的对象使用，  
但只能使用从基类继承的成员。

### 2. 虚函数

**虚函数**是动态联编的基础，  
**非静态函数**是虚函数的基础。

```c++
virtual int func()
```

只能在类内使用`virtual`。

### 3. 多态中虚函数判定标准

设置虚函数后，通过基类类型的指针，就能访问到正在指向的对象的成员。  
如果没显示指定虚函数，编辑器会根据以下三种情况自动添加：

## 四、多态的实现

动态联编如何实现？

将所有虚函数，建立为一个虚函数表。

## 五、注意事项

### 1. 构造函数和析构函数调用虚函数

若构造析构函数里调用了虚函数，  
调用的是自己类的函数。

若自己类不存在，则向父类查找。

即采用静态联编。

### 2. 普通成员函数调用虚函数

普通成员函数调用的是实际的虚函数，  
采用动态联编。

### 3. 私有虚函数和非虚结构

只提供接口函数供外部访问

### 4. 带默认参数的虚函数

虚函数是动态绑定的，  
缺省参数是静态绑定的。

### 5. 返回值是自己对象指针

## 六、纯虚函数与抽象类

### 1. 纯虚函数

在基类中说明的虚函数，在该基类中没有定义具体的操作内容，  
要求个派生类根据实际需要定义自己的版本。

```c++
virtual 函数类型 函数名 (参数表) = 0;
```

### 2. 抽象类

包含纯虚函数的类。

* 只能作为基类，来派生新类使用
* 不能创建抽象类的对象
* 只能定义抽象类的指针，链接到派生对象。


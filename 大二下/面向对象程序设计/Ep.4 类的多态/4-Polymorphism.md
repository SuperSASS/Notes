# Ep.4 类的多态

C++是通过“向对象**发送消息**”来处理对象的，  
每个对象根据所接收到的消息，来**决定各自需要采取的行动**，  
从而响应这个消息。

响应这些消息的是一系列的方法，  
方法是在类定义中，使用函数来定义的，  
因此C++是是用一种**类似于函数调用的机制**，把**消息发送到一个对象上**。

⭐**关键：同名函数，不同实现方式。**

多态有**两种理解**：

* 相同对象收到不同消息。
* 相同消息被不同类型的对象接受。

一般指第二种。  
这两种多态，都会产生不同的行为，即**调用了不同的函数**。

## 一、多态的种类

根据在**哪个阶段**实现的多态，可以分为两种：

* 编译时的多态
* 运行时的多态

### 1. 静态多态

指的是在编译的时候就能知道所有方法调用的是哪些函数，  
是能在**编译的时候就确定**。

静态多态的分类：

* 函数多态
  * 普通函数的重载
  * 类的成员函数的重载
  * 运算符重载
* 宏多态
* 模板多态
  * 使用“类模板”

#### (1) 函数多态

即对**同名函数**，采用**不同的参数值**，可实现重载，从而达到多态。  
如之前所学的“构造函数重载”。

#### (2) 宏多态

```c++
#define _ADD(A,B) (A)+(B)

int main()
{
  double d = _ADD(d1, d2); // 浮点数相加
  int i = _ADD(i1, i2);    // 整型相加
}
```

因为宏直接将内容替换，因此也可以适应不同类型的数据，  
带变量的宏多态可实现一种**初级形式的静态多态**。

*但其本质还是运算符的重载带来的多态，如上面的`+`，则是因为对`int`和`double`都重载了。*

#### (3) 模板多态

如`sort()`的参数`cmp()`，  
根据不同的`cmp()`执行不同的方法。

```c++
int cmp(const int &a, const int &b) { return a > b; }

int main()
{
  sort(x, x+n);      // 升序排列
  sort(x, x+n, cmp); // 降序排列
}
```

*其本质还是函数多态。*

### 2. 动态多态

动态多态性使实现面向对象技术的基础。

通过一个**指向基类**的**指针**，调用**虚成员函数**的时候，  
运行时系统将能够根据指针所指向的实际对象，调用恰当的成员函数。

关键：**利用指针或引用**，指向或引用哪个类，就调用谁的函数。  
*一定是利用指针或引用！*

## 二、多态的实现

利用“联编”技术实现多态。

> 定义 - 联编（绑定）:
>
> 将函数体和函数调用关联起来。  
> 即确定执行特定的函数代码块的过程就是联编。
>
> 在面向对象中即指：消息（调用一个函数）与对象的方法（实际调用的哪个类里的函数）相结合。

* 静态联编：联编在**编译连接阶段**完成。  
  通过用户指定调用的成员函数，在编译时根据类对象，来确定调用该成员函数的方法。  
  对应上面的静态多态。
* 动态联编：联编工作在**程序运行中**的情况。  
  需要将成员函数声明为“**虚函数**”(`virtual`)，然后再用基类的指针指向派生类对象。  
  对应上面的动态多态。

## 三、多态实现规则

有以下三个原则：

1. 满足赋值兼容规则
2. 存在虚函数
3. ？

### 1. 赋值兼容规则

> 定义 - 赋值兼容规则：
>
> 在需要**基类**对象的任何地方，都可以使用**公有派生类**的的对象来代替。  
> 在代替之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。

* 向上兼容性  
  基类赋值给派生类。
* 向下兼容性  
  派生类赋值给基类。必须显式转换，会丢失数据。

定义基类类型指针，指向派生类对象。

```c++
class Base;
class Derived : public Base;

int main()
{
  Derived rectangle, triangle, circle;

  Base  graph   = rectangle;
  Base& r_graph = triangle;
  Base* p_graph = circke;
}
```

需要基类对象的任何地方，都可以使用公有派生类的对象来代替。  
代替之后，派生类对象就可以作为基类的对象使用，  
但只能使用从基类继承的成员。

### 2. 虚函数

**虚函数**是动态联编的基础，  
**非静态函数**是虚函数的基础。

```c++
virtual int func()
```

只能在类内使用`virtual`。

### 3. 多态中虚函数判定标准

设置虚函数后，通过基类类型的指针，就能访问到正在指向的对象的成员。  
如果没显示指定虚函数，编辑器会根据以下三种情况自动添加：

## 四、多态的实现

动态联编如何实现？

将所有虚函数，建立为一个虚函数表。

## 五、注意事项

### 1. 构造函数和析构函数调用虚函数

若构造析构函数里调用了虚函数，  
调用的是自己类的函数。

若自己类不存在，则向父类查找。

即采用静态联编。

### 2. 普通成员函数调用虚函数

普通成员函数调用的是实际的虚函数，  
采用动态联编。

### 3. 私有虚函数和非虚结构

只提供接口函数供外部访问

### 4. 带默认参数的虚函数

虚函数是动态绑定的，  
缺省参数是静态绑定的。

### 5. 返回值是自己对象指针

## 六、纯虚函数与抽象类

### 1. 纯虚函数

在基类中说明的虚函数，在该基类中没有定义具体的操作内容，  
要求个派生类根据实际需要定义自己的版本。

```c++
virtual 函数类型 函数名 (参数表) = 0;
```

### 2. 抽象类

包含纯虚函数的类。

* 只能作为基类，来派生新类使用
* 不能创建抽象类的对象
* 只能定义抽象类的指针，链接到派生对象。


---

## 运算符重载

需要注意，对于`+`这样的二元运算符，  
如果要支持`int + CType`，  
则需要把运算符重载为**友元函数**。

```c++
class Complex
{
  friend Complex operator+ (double r, const Complex &c);
}

Complex::opeartor+(double r, const Complex &c)
{
  return ...
}
// 之后才可以调用 5.0+ComplexVar;
```

特殊运算符重载：
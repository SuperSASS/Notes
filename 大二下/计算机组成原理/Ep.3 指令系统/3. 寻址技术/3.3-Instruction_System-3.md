# 第三节 寻址技术

用在寻找执行完一条指令后的下一条指令。

包括：

* 指令寻址
* 数据寻址

## 一、基本的数据寻址方式

若不存在寻址方式，直接将操作数字段定为有效地址而去寻找，  
则位数少，所能涉及到的存储器空间少；且太死板。

因此可以采用若干种特殊的寻址方式，  
针对不同的寻址方式，有不同的确定地址方式（如在CPU寄存器中寻找、在内存中寻找；顺序找倒序找等等）。

> 定义 - 寻址方式：
>
> 数据寻址方式：由指令中“形式地址”，确定有效地址的方式。
>
> * 形式地址：指令中字段给出的地址。通常**不能直接访问存储器**。
> * 有效地址：形式地址经过一定的计算而得到的，能**直接访问存储器**的地址。

采用寻址方式的原因：

* 操作数地址**表示多样化**需要。
* **压缩**操作数地址字段的**长度**。

### 1. 立即寻址

地址码字段里存的：就是“**操作数**”。  
但因为存在多种寻址方式，所以还是要给出决定寻址方式的字段。
![立即寻址方式](images/3.3-Instruction_System-3--04-18_11-02-16.png)

### 2. 直接寻址

地址码字段里存的：就是**主存中的有效地址**`EA`。

### 3. 间接寻址

地址码字段里存的：是主存中**有效地址的地址**`A`。

需要访问两次主存才能取出操作数。  
虽然耗费更多时间，但可以**扩大寻址范围**，  
用短地址的指令访问长地址的主存。

### 4. 寄存器寻址

地址码字段里存的：是在 CPU 中通用**寄存器的地址**。

CPU 中存在较少数目的“通用寄存器”。  
若数据存放在通用寄存器，这采用这种寻址方式。

### 5. 寄存器间接寻址

地址码字段里存的：是**寄存器**中**有效地址的地址**。  
寄存器中存放操作数在内存的的有效地址。

就是间接寻址，把从主存找地址变成寄存器找地址。

也是短指令，访问内存大，但速度比间接寻址更快。

### 6. 隐含寻址

没有地址码，  
而在**操作码中隐含着操作数的地址**。  
`EA=`操作码`OP`所约定的那个寄存器。

> e.g. X86中`LOOP`指令，就隐含使用了CX寄存器。

### 7. 偏移量寻址方式

有三种：

* 变址寻址
* 基址寻址
* 相对寻址

都是给定一个形式地址，加上偏移量，得到有效地址的形式。

> 注 - 有关地址的操作符号：
>
> * `(A)` 代表 取操作数，相当于C++的`*A`，得到的是一个操作数。
> * `[A]` 代表 取地址，相当于C++的`&A`，得到的是一个地址。
> * `[7FFFH]` 代表 取内容，相当于C++的`*0x7FFF`，得到的是一个操作数。

#### (1) 变址寻址

有效地址`EA` $=$ 变址寄存器的偏移量`(Rx)` $+$ 形式地址`A`

* `(Rx)` - 变址寄存器中的地址，寄存器里面存的是偏移量
* `A` - 基准地址

`(Rx)`会与`A`在ALU中相加，得到在内存的真实地址。

#### (2) 基址寻址

有效地址`EA` $=$ 变址寄存器的偏移量`(Rb)` $+$ 形式地址`D`

* `(Rb)` - 基准寄存器中的地址，寄存器里面存的是基准地址
* `D` - 偏移量

`(Rb)`会与`D`在ALU中相加，得到在内存的真实地址。  
没有`D`，则是寄存器间接寻址。

> 区别 - 变址寻址和基址寻址
>
> * **变址寻址**
>   * 变址寄存器提供“偏移量”
>   * 形式地址提供“基准地址”
>   * **面向用户**
> * **基址寻址**
>   * 变址寄存器提供“基准地址”
>   * 形式地址提供“偏移量”
>   * **面向操作系统**

#### (3) 相对寻址

`EA` $=$ `(PC)` + `D`

* `(PC)` - 当前指令的内存地址，已在寄存器`PC`中不用给出。
* `D` - 偏移量

### 8. 页面寻址

将主存划分成若干页，  
短指令可以整添代表页号的部分，因此也能扩展寻址范围。

#### (1) 基页寻址

`EA` $=$ `O//A`

#### (2)当前页寻址

`EA` $=$ `(PC)_H//A`

#### (3) 页寄存器寻址

页号存在一个页寄存器中。

## 二、寻址方式的表示方式

即如何知名采用了哪种寻址方式。

1. 显示  
   在指令中设置专门的寻址方式字段。
2. 隐式  
   约定某种操作码，就是某种寻址方式。
# 汇编

## 0x01 造成编译出的汇编程序不同的原因

### 1. CPU架构

要先知道用的处理器是什么架构，  
**不同架构**（尤其是`x86`和`x64`），编译出来的**汇编程序差别很大**。

由于`ARM`多用于移动端，  
下面只对架构大类的`x86`进行介绍。

* `x86` - 是一种**架构体系**。  
  以Intel和AMD的处理器为主，其现在所有的CPU（如Core全系列）都是`x86`架构体系的。

  里面有很多的种类（不同指令集）：`x86-16`、`x86-32`(`IA-32`)、`x86-64`(`AMD64`, `Intel 64`)  
  但都是基于`x86-16`指令集发展而来的。

  ⚠由此可见：`x86`在狭义上只指`x86-32`，为32位；但广义上一种**泛称**，包括了16位(8086)、32位、64位的CPU。
  > 名称来源：
  >
  > 该架构的始祖是“Intel 8086”，为第一款**16位处理器**，  
  > 之后基于它发展的“80286”、“80486”等都以86结尾。  
  > 故该架构体系称为`x86`。

  具体的指令集包括：

  * `x86-32` - 即32位的`x86`架构CPU，前几年来说最常用的架构。  
    等价称呼：`IA-32`、`i386`。  
    简称：`x86`。
    > 拓展 - `i*86`：
    >
    > 是对`x86-32`的部分CPU的别称，具体如下：
    >
    > * `i386` - 最早对应CPU“Intel 80386”，也是第一款`IA-32`架构的CPU（由于兼容，之后的`i*86`也使用，所以就代指所有的`x86-32`了）。
    > * `i486` - 最早对应CPU“Intel 80486”。
    > * `i586` - 最早对应CPU“Intel Pentium”（这之后Intel的CPU就不再是一串数字了），也称“P5”微处理架构。
    > * `i686` - 最早对应CPU“Intel Pentium II”，也称“P6”微处理架构。
    > * *`i786` - 对应CPU“Intel Pentium 4”，也称“P68”或“NetBurst”【一般很少用都是隐藏的，所以不用管的……
    >
    > 故现在用`i*86`表示的话，就用`i386`表示了，其跟`x86-32`(简化为`x86`)是一样的。

  * `x86-64` - ⚠是若干指令集的统称（无偏向性的称呼）  
    包括了：AMD的`AMD64`、Intel的`Intel 64`（或称为`CT`、`IA-32e`、`EM64T`）  
    等价称呼：`x86_64`、`amd64`(特别注意这个：虽然叫amd，但AMD和Intel的64位都是)
    简称：`x64`。【微软发明的简称，导致后面很多人问：为什么64位是`x64`，而32位不是`x32`_(:зゝ∠)_……
    * `AMD64` - 是AMD最先研发的，在`x86-32`基础上扩展为64位的指令集，吊打了Intel同期研发的64位新架构`iA-64`。  
      故成为了公认的`x86-64`实际标准。
    * `Intel 64` - 是Intel在输麻了之后，被迫接受`AMD64`并做了些许改动的指令集【就改个名x……
    > 拓展 - `IA-64`架构：
    >
    > 最早的64位是Intel研发的，为`IA-64`架构，所用的CPU有Itanium系列，  
    > 不过其完全摒弃了`IA-32`架构，也就是完全不兼容（否则就不叫一个架构了，正因为不兼容才是个新架构）  
    > 因此后来被兼容`x86-32`的`AMD64`给吊打了，后面只能放弃`IA-64`架构。
    >
    > 后面Intel采用`AMD64`指令集后，为了不丢人，改称为上面括号里那么多的或称。  
    > 最后改称为`Intel 64`。
    >
    > 但需要注意，因为`IA-64`不兼容`IA-32`，所以不算在`x86`架构里。

主要参考于：[i386、i486、i586、 i686、 x86、x86_64、x64、amd_64详解](https://www.jianshu.com/p/70872b91ab46?utm_campaign=haruki&utm_content=note&utm_medium=writer_share&utm_source=weibo)。

### 2. 编译器

编译器：用于把高级程序语言，编译成汇编语言。

> 有关人类如何“把人类的自然语言（思想）一步步转换成计算机能够执行的机器指令”这一过程，  
> 对于用C类语言的只用记住过程大致为：“源程序 ---编译器---> 汇编程序 ---汇编器---> 机器指令”。  
> 更加详细的过程以及解释器、虚拟机之类的内容可以自行搜索。【或自学编译原理x……  
> 以后可能补充【主要是之前看到的一篇知乎回答找不到了orz……

也需要注意：不同的编译器，也会对编译出来的汇编语言产生很大区别。

以下介绍常用的几类编译器：

* MSVC - VS编译器
  * cl
* GUN - 编译器集合
  * gcc
  * g++
* MinGW - GUN的Windows移植
* LLVM
  * Clang

可见[有没有大佬给我讲解一下MSVC、MINGW,gcc、g++,qmake、cmake的联系和区别是什么？ - 周旋的回答 - 知乎](https://www.zhihu.com/question/333560253/answer/2282723843)

---

* CPU架构：`x86-64`(`Intel 64`)
* 编译器：`MSVC 14.31.31103`(Visual Studio 2022)

以下主要以该配置进行讲解。

## 0x02 寄存器

内存模型：下方为小地址`0x00`，上方为大地址`0xFF`。

* 栈 - 向下生长。即栈顶在下，扩栈(push)时`EPS-n`。（理解为钟乳石）
  * `ESP` - 栈顶地址
  * `EBP` - 栈基地址

## 0x03 指令

* `mov`和`lea`(Load Effective Sddress)的区别：  
  两者都是将源操作数赋给目的操作数，但在取地址和取值上是相反的。
  * `mov eax, [ebx+4]` - 将`ebx+4`当作地址，其指向的值赋给`eax`。
  * `lea eax, [ebx+4]` - 将`ebx+4`赋给`eax`。

# 三、SQL Server完整性约束

不同于第二章的概念数据模型，对应概念数据模型，  
本章对应逻辑数据模型，因此需要选择具体的DBMS。

对于SQL，是一个标准，  
不同DBMS有自己的实现方式，称为数据库方言。

## 一、T-SQL语言

对于Microsoft的SQL Server,则采用的是Transact-SQL,  
称为事务SQL。

T-SQL由SQL语句（DDL、DML、DCL）、函数和存储过程组成。  
还具备过程控制能力和事务控制能力。

有两类变量：

* 局部变量：用户自己定义的变量。用`@`表示。  
  如`@name`。
* 全部变量：由系统定义，只能应用，不能修改和定义，用`@@`表示。  
  如`@@error`。

下面将DDL。

## 二、完整性定义——表的定义及基础操作

### 1. 表的定义

```SQL
CREATE TABLE [数据库名.[拥有者]. | 拥有者.] 表名
  ( { <列定义>
    | 列名 AS 列计算表达式
    | <表级约束> }
  | [ { PRIMARY KEY | UNIQUE } [,...] ]
  ) [ON {filegroup| DEFAULT}]

<列定义>::= 
   { <列名> <列类型> [NULL|NOT NULL] }
   [ [ DEFAULT 常数表达式]
   | [ IDENTITY [ ( 初值 , 步长 ) [ NOT FOR REPLICATION ] ] ] 
   [ROWGUIDCOL]
   [ <列级约束> ] [ ... ]
   
<表级约束>::=
  [CONSTRAINT 约束名]
  { [ FOREIGN KEY [(列名 [,…])] REFERENCES 参照表[(参照列[，…])] ]
    [ON DELETE {CASCADE | NO ACTION}]
    [ON UPDATE {CASCADE | NO ACTION}]
  }
```

* `[]` - 代表可省略。
* `[,...]` - 代表可重复。
* `()` - 就是对小括号，源码中要写。
* `<>` - 代表一种定义（一个语句块），定义在后面用`::=`表示。
* `{ | }` - 必须选择其中一项。

### 2. 表的插入、查询

插入：

```SQL
INSERT
```

查询：

```SQL
SELECT
```

最基础：`SELECT * from ...`

> e.g.
>
> 对如下ER图进行建表：
> ![ER图建表示例](images/3.1-Relational_Data_Model-1--04-07_10-25-08.png)
>
> 则对应代码：
>
> ```SQL
> CREATE TABLE Student
> (
>   SNo char(10) Primary Key,
>   SName varchar(20) Not Null,
>   Major varchar(50) Not Null,
>   SIDC char(18) Unique,
>   SAge as datepart(yyyy, GetDate()) - datepart(yyyy, convert(DateTime, substring(SICD,7,8)))
> )
> ```
>
> 接下来还可以执行操作：
>
> ```SQL
> INSERT Student values('1001','王晓丽','计算机应用','120221200005110027')
> INSERT Student values('1002','张大强','物联网','510106199806250228')
> INSERT Student values('1003','余丽丽','物联网','510106199908260335')
> ```
>
> ---
>
> 对外键的代码：
>
> ```SQL
> CREATE TABLE CTake
> (
>   CID char(10) Foreign Key references Course(CID), 
>   SIDC char(10) Foreign Key references Student(SIDC) On DElETE cascade On UPDATE cascade, 
>   mark smallint,
>   term date,
>   Primary Key (CID,SIDC) /* 注意： 联合主键只能这样定义，不能在字段后面加Primary Key */
> )
> ```

### 3. 常用函数

常用的日期处理函数：

```SQL
GetDate() /* 返回系统（是服务器端，不是用户端）日期的日期与时间 */
DateDiff(interval, date1, date2) /* 返回date1与date2之间，关于interval（如DD,YYYY）的差值date2 - date1 */
DateAdd() /* 同diff, 但是加。 */
DatePart(interval, date) /* 从date中某一部分 */
DateName(date) /* 返回名字 */
```

常用的字符串处理函数：

```SQL
Left(char, int) /* 从最左侧取n位 */
Right(char, int) /* 从最右侧取n位 */
SubString(char, int n, int m) /* 从n位开始截取m位 */
```

## 三、数据类型

* 整数数据类型
  * `int` - 默认的整数类型，规定为4个字节($-2^{32}\sim2^{32}-1$)。
  * `bigint` - 8个字节($-2^{64}\sim2^{64}-1$)。
  * `smallint` - 2个字节($-2^{15}\sim2^{15}-1$)。
  * `tinyint` - 1个字节($-2^8\sim2^8-1$)。
* 浮点数数据类型
  * `decimal(p, s)` - 精确浮点数
    * p - 数字的精度，范围为$1\sim38$（默认为18）。
    * s - 取值范围为$0\sim p$
  * `real` - 精确到7位，占4字节。
  * `float` - 精确到15位，占8字节。
* 字符数据类型
  * 非Unicode字符数据
    * `char(n)` - 固定长度字符串，长度不足$n$时会填充空格。  
      n范围为$0\sim255$。  
      不能统一用`char`，否则浪费空间。
    * `varchar(n)` - 可变长度字符串，不会补空格，而会自动收回多余长度空间。  
      n范围为$0\sim255$。  
      不能统一用`varchar`，否则会降低效率。
    * `text` - 存放$0\sim65535$个字符的字符串。
  * Unicode字符数据
    * `nchar`
    * `nvarchar`
    * `ntext`
* 日期和时间数据类型
  * `DateTime` - 存储日期和精确时间，格式：`YYYY-MM-DD hh:mm:ss[.nnn]`。占8字节。
  * `SmallDataTime` - 储存日期和简单时间，格式`YYYY-MM-DD hh:mm:ss`。占4字节。
  * `Data` - 只存储日期。占3字节。
  * `Time` - 只存储超精度时间，格式`hh:mm:ss[.nnnnnnnn]`，精度为100ns，占3-5字节。
* 货币数据类型
  * `Money` - 范围$-2^{63}\sim2^{63}-1$，精度为$19$，小数位数为$4$，占8字节。
  * `SmallMoney` - 范围$-2^{31}\sim2^{31}-1$，精度为$10$，小数位数为$4$，占4字节。
* 位数据类型
  * `bit` - 只取`0`、`1`，约等于`bool`。
  
## 四、完整性验证

### 1. 默认值 - default

为列或“用户自定义数据类型”指定缺省值，只能拥有一个。  
如果用户没有在该字段上给出初始值，则用默认值。

1. 给某个表的某个字段定义默认值

   ```sql

   ```

2. 用单独的命令创建`default`  
   有些默认值可能是多组共用的，  
   或者一段时间后想给某表加上默认值，  
   则采用这种方式。

   ```sql
   CREATE DEFAULT def_name as <缺省值>
   sp_bindefault def_name,'Table.which'
   ```

需要取消绑定，则用`DROP DEFAULT`和`sp_unbindefault`

### 2. 规则 - rule

**只能单独定义**。

```sql
CREATE RULE rule_name as <表达式>/*如: @mark between 0 and 100*/
sp_bindrule rule_name, 'Table.which'
```

可用以下规则：

* `in(...)` - 对字符串限定取值，限定为括号内的字符串。
* `between ... and ...` - 对整数限定取值
* `and ...`
* 关系式`<`、`<>`（不等于）
* `like` - 正则表达式规则

删除规则，`sp_unbindrule`和`DROP RULE`

### 3. 检查 - check

跟rule类似，不过是在**创建表的时候写的**。  
用`constraint`表示要创建检查，然后输入检查名（可省略），  
接下来输入`check(...)`，`...`为同规则一样的表达式。

规则为动态绑定，检查为静态定义。

```sql
CREATE TABLE TableName
(
  ID char(4) Primary Key CONSTRAINT ID_constraint CHECK(ID in('1001','1002')) or like(...)
)
```

### 4. 之前的完整性约束

1. 主键约束 - `primary key`
   对于一个主键，可以直接加在字段后，  
   对于联合主键，必须另外用`Primary Key(..., ...)`写出。
2. 唯一约束 - `unique`
3. 外键约束 - `foreign key`  
   两种策略：
   * `cascade`
   * `no action` - 默认
4. 触发器 - `trigger`  

   ```sql
   CREATE TRIGGER tri_name on table_name
   for { INSERT | UPDATE | DELETE} [,...]
   as <语句> return
   ```

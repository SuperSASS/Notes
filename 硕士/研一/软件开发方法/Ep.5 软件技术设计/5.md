# Ep.5 软件技术设计

## 一、理解架构

> 架构，来源于建筑学，涉及的范围包括：
>
> * 建模（设计）
> * 过程
> * 工具
>
> 对于一个房子，可以采用分层来进行设计：
>
> * 地基
> * 内部装饰
> * 内部规划
> * 服务层
> * 结构层
> * 外部装饰

**软件复杂性维度**：

* 业务复杂性
  * 高：大规模、有正式合同、用户多、功能不断变化
  * 低：小规模、非正式、用户单一、功能确定
* 技术复杂性
  * 高：嵌入式、分布式、实时、高性能高并发
  * 低：图形化开发、组件复用、业务重构、性能要求不高

**驱动力**：  
在做架构设计的时候要考虑的因素。

* **功能**（最核心的）
* 兼容性
* 可用性
* 安全
* ……

**定义 - 架构设计**：  
定义系统的**解决方案**的过程，用于满足所有的技术和业务需求，同时优化系统的质量属性。  
**架构设计活动**包括一系列的设计决策，综合考虑各方面影响因素，每个决策都会影响系统，以至于最终使得系统获得成功。  
**软件系统架构**由系统的一组结构组织，包含了各类软件元素……

软件结构决定了一个系统的主体、宏观结构、具有的基本功能和属性。  
**设计**是基于功能需求都达到的前提，因此更多侧重于**非功能需求**。

## 二、架构设计模式

架构通常是参考其他成熟的架构设计，及软件架构模式。

**架构模式**则是由那些软件架构师通过持续实践，进而总结出的、过往已验证的、优秀的设计架构，  
是在给定上下文的软件架构中，针对常发生问题的一种**通用的、复用的解决方案**。  
帮助定义了软件系统的基本特征和行为。

经典的、新的架构模式：

* 分层
* 事件驱动：高并发、事件处理量大
* 微内核
* 微服务
* 虚拟化 / 云化

### 1. 分层架构

分层架构(N-Tier)是最经典的架构模式。  
在分层架构模式中，将应用分成多个水平层，每层在应用中担任一个专门角色。

通常由这 4 个层次构成：

* 表现层：界面、与用户打交道
* 业务层：业务逻辑
* 持久层(Persistence Layer)：数据库的连接、访问、处理
* 数据库

要求层与层之间**不能跨层访问**，这样各层之间才能职责分明、降低耦合。

**优点**：

* 组件只属于某个特定层面、具有良好的易测试性
* 业余能够划分为逐层分离的功能集，易于被开发
* 不同层次相对独立，能分配单独的开发角色
* 能对不同层次单独更新和增强

### 2. 事件驱动

事件驱动架构是一种很流行的**异步分布模式**，  
可生成高扩展性、强适应能力的应用，可应用于小程序或大型复杂程序。  
在编写高并发的应用时可以优先想到这种架构。

事件驱动架构是由高耦合度、单一目的的**事件处理模块**构成，  
这些模块异步接受、处理事件。

核心的思想是请求全部接收、但并不及时处理、而是排队等候，即“**事件/消息队列**”。

**有两种模式**：

1. 中介人(Mediator)：有一个事件中介人，负责分发等候在“事件队列”里的各类事件，到不同的事件处理模块中。  
   中介人是核心模块，如果崩掉则系统完全崩掉。  
2. 代理(Broker)

不同模式还有不同的实现方式。

**适用**：开发具有高度可扩展性系统的分布式异步架构

**优点**：

* 容易适应复杂且混乱的环境
* 可被轻松实现
* 有很多成熟的中间件（消息队列）

### 3. 微内核

也称为**插件(Plug-in)架构**，是实现基于产品应用（有很多功能且持续更新）的一种自然模式。  
可以让用户添加额外的插件到核心应用，继而提供了可扩展性和功能分离的用法。

整个系统由**内核系统**、**插件系统**两部分组成，  
应用逻辑分为独立的插件模块和基本核心模块，继而有扩展性、灵活性，同时隔离应用程序功能和处理特定事物的逻辑。

*如 VSCode 则是经典的插件架构。*

**优势**：

* 可扩展性很强
* 各插件可以单独测试，不影响内核系统

### 4. 微服务

将单体应用程序变化为面向服务架构的微服务，是现在互联网的主流架构。  
将业务分解成多个协同工作的微服务，每个微服务都有自己的职责，团队可以独立于其他微服务进行开发。

每个业务比较独立、可以组合。  
业务拆分为微服务后可以单独部署扩容，降低资源浪费（不再是对整个单体应用扩容）。

各个服务组件基于 RESTful 风格接口与用户接口进行通信。

**优势**：

* 可以单独地编写、维护和部署每一个微服务
* 可以灵活地扩展那些需要的服务
* 提供良好的可维护性、可测试型，以实现快速且频繁的开发和部署

### 5. 虚拟化 / 云化

*其实并不算一种特定的架构，更多是一种技术。*

适用于解决高可扩展性和高并发问题。  
将各种资源进行虚拟化，放到云上处理。

适用于用户规模具有很大变化或不可预见性的系统。  

## 三、架构设计过程

*如何来做架构的设计。*

**阶段**：

1. 确定架构原型
2. 选择部署策略
3. 确定技术方案
4. 解决质量属性：验证各种质量属性（功能一定可以实现、更多考虑非功能）

### 1. 确定架构原型

得到“逻辑架构图”。

**方式** - 根据应用类型确定架构原型：

* 移动端应用
* 胖客户端应用
* 胖服务端应用
* Web 应用
* 面向服务的应用

### 2. 选择部署策略

程序必须要部署到具体的物理环境，所以要考虑应用程序架构。

*以前因为要提前准备物理服务器，所以很重要；现在因为云的发达，这部分不是太重要、不需要提前做。*

**考虑因素**：

* 目标物理环境
* 安全
* ……

**两种部署策略**：

* 集中式部署  
  有一个 Web 服务器、有一个数据库服务器
* 分布式部署  
  需要进一步考虑：通信、事务和安全（认证 / 授权）、状态管理、一致性等……

### 3. 技术方案选型

根据架构和部署策略选择技术路线

* 应用框架/分层技术：Jave EE、.NET
* 开发工具：IDEA
* 数据库：MySQL
* 工作流：JBPM、Activiti
* 消息队列、Kafka、...MQ
* 移动端技术
* Web 服务器：Tomcat、IIS

形成技术栈。

### 4. 解决质量属性

首先保证功能是默认前提，在此基础上验证性能、缓存、可靠性、安全等。

分为：

* 设计时：在设计的时候能分析出来的
  * 概念完整性（文档规范、用词一致）
  * 可维护性
  * 可复用性
  * 可测试
  * 可支持
* 运行时：在运行时才能体现出来的
  * 可用性
  * 互操作性、跨平台
  * 可管理性
  * 性能
  * 可靠性
  * 可扩展性
  * 安全性
* 用户体验：UI
  * 易用性

**性能问题的解决方案**：

* 纵向扩展：提高单台服务器的性能
* 横向扩展：采用分布式策略、增加多台服务器

**可靠性问题的解决方案**：

冗余备份。

**安全问题**：

* 认证(Authentication)
* 授权(Authorization)
* 输入数据检验
* 敏感数据保护(Sensitive data)
* 配置管理
* 加密
* Session 管理
* 审计和日志(Auditing)
* 异常处理

通常只有同在一个内网中才认为链路是可信的；一旦经过公网，要秉承着“链路不可信”原则考虑安全问题。

方法有：

* 设定各类角色和访问模式

**缓存问题**：

缓存对性能有很大影响，要考虑：

* 哪些数据要缓存
* 缓存的位置
* 缓存数据的格式
* 合适的缓存管理策略，何时失效
* 如何加载缓存诗句

有两种缓存方案：

* 独立的缓存服务器(Redis)
* 各级继承的缓存（页面缓存、数据缓存（html, css, js））

## 四、构件设计过程

在这个过程中，以架构为输入、围绕需求（用例）开展分析设计

* 用例分析、设计、协作建模  
  以功能需求为输入，构造分析 / 设计模型，定义对象间的交互，以实现用例行为
* 类设计  
  定义类结构，作为实现的输入
* 重构设计模型  
  综合考虑设计原则、模式、优化设计方案

### 1. 用例分析

用“交互图”（顺序图）来描述用例的逻辑，用“类图”来进行功能归类和划分。

### 2. 类设计

* 创建初始的设计类
  * 边界类（用户界面类）
  * 控制类（流程控制、数据访问、事务管理、安全控制）
  * 实体类

  提取抽象类、接口类
* 确定类的属性  
  可见性 属性名称 [重数]: 类型 = 初始值
* 确定类操作和方法  
  操作是对类指责的接口定义；方法则是操作的实现（具体代码）。  
  操作定义在 UML 类图中；方法可以用活动图描述。
* 精炼类之间的关系
  * 依赖（最弱的、虚线）：是一种使用关系（拥有关系不是使用关系）、需求上不用表达，因为很普遍类图上也一般不画
  * 关联（箭头，两者平等）：比如拥有关系
  * 聚合（更强的关联，菱形为整体，另一端为部分，但可以脱离）
  * 组合（更强的聚合，实心菱形，部分不能脱离整体）
  * 泛化（空心三角）：继承
  * 实现（虚线空心三角、类和接口的关系）

### 3. 引入设计模式

在对象设计中可以使用各种“设计模式”，来简化优化构件设计。  
如“策略模式”等

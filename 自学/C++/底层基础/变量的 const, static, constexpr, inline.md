# 变量的 const, static, constexpr, inline

从 C++98 开始，对于变量的值有这样两个概念：

* 值在编译时确定：值可以在编译的时候就确定是多少，在运行时**不会变化**，同时**与操作系统具体实现无关**（很重要的一点）。这种变量可以进行**内联** - **进行替换**，并**不需要开辟内存**实际存储这个变量。  
  这个实际上**对应常量的概念** - 是一个公认的数据，可以直接替换（提到`pi`就想到`3.14...`）。  
* 值在运行时确定：值不能在编译时确定，必须要有空间存储，并在运行时找到定义（可能是一开始就有（类的静态变量），也可能是后来才有（类的 const 变量，初始化实例时指定））；或者即便在编译时可以确定，但后面**可能**会进行改动

* const - 实际上应该是“只读”(readonly)，而并不是“**常量**”（将其说为常量，是因为对应数学上常量的概念是“不可变”这个属性）。
* static - 静态：

这里只考虑对于类的数据成员：

* C++98 - 只有 `const`, `static`
  * 运行时确定
    * `const` - 属于类**实例**的常量：如每个人的性别，可以不同，但不能更改；但在其出生之前是不知道的。
    * `static` - 描述属于共同的类本身而非属于各个实例：如所有人类的物种出现时长、每个人都相同，且都随着日期增加都在增加  
      为了解决类的共有（不是公有）属性而出现的，因为这种需求是实际存在的，如果没有`static T`这个语法：
      * 用`T`，则当发生变化时，需要对每一个实例进行修改、明显不现实。
      * 可能会想到用`T&`，然后指向一个类外部全局变量，而**这正是`static`进行的操作**

      因此，在定义类的静态成员变量时，在类内部只能声明，而定义需要在类外部，使得其作为一个**类外在堆上的全局变量**,  
      类实例不会存在这个变量的存储，只保存一份副本，节约了空间。

      如果在类内部初始化，则每次创建类实例，都可能会尝试开辟内存存储，与只有一个副本矛盾（虽然理论上可以让链接器（注意，编译器都不行）检测是否之前是否创建过，但代价太大）
  * 编译时确定
    * `static const int/char...`  
      存在这样的需求，有些简单的值是编译时就可以确定的，这些可以进行内联处理直接替换，故**可以在类内定义**。但因当时技术限制，**只有各种整形**可以实现。  
      整型常量在编译时就能确定其值，且编译器通常可以在编译期间对这些常量**进行内联处理**。  
      由于这些是编译时常量，定义可以在多个文件中被包含，但因为内联处理而不会违反ODR（One Definition Rule，一次定义规则）。
  * 运行时确定
    * `static const double/std::string/...`  
      这种只能在运行时确定，因为与具体平台的实现有关，尤其是`double`，浮点运算可能与平台相关。
* C++11 - `constexpr` 出现
  * `static const int/T` - 同 C++98
  * `static constexpr T` - 会隐式进行内联处理，但如果需要存储（典型有取地址、被传递给引用的参数），则无法内联，此时仍然需要类外定义。  
    故在这个版本的处理方法：
    * 一般是在声明文件`.h`中类内进行初始化赋值，在实现文件`.cpp`中类外再进行一个声明，防止出现未定义问题。  
    * 如果声明和定义放在一个`.hpp`文件，则无较好解决方法（如果添加类外定义，则会出现重复定义的错误），一个方式是不再放在类中，而是放在命名空间中作为全局静态变量。
* C++17 - `inline`变量 出现之后
  * `static constexpr` - 默认内联

---

## asm 理解

* `inline`
  * 全局函数（非类成员函数）：在对其定义的源文件（但inline需要声明和定义在一起，故也是`.h`文件）中并不编译出对应定义代码，而是在使用该函数的源文件中直接复制其定义（将原本定义在对应源文件的汇编码，复制到调用者的源文件的汇编结果中），并且是局部的，不会导致重复定义。  
    *注：暂时不清楚拒绝内联后，作为全局函数，定义被复制多次（多次包含后）是否会出现重复定义的问题。*
  * 类成员函数
  * 变量：直接替换为值
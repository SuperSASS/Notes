# Ep.2 软件过程

## 一、介绍

### 1. 定义

> 定义 - 软件过程：
>
> 软件过程是**软件工程人员**，为了**获得软件产品**，而在**软件工具的支持**下，实施的一系列**软件工程活动**。

**需定义**（即**基本元素**）：

* 团队人员的工作和指责
* 所执行的活动及其顺序关系
* 活动的内容和步骤
* 如何交付和评议标准

**好处**：

* 降低风险
* 用户可根据反馈参与软件设计

### 2. 体系结构

**主要的软件过程元素**：

* 需求分析
* 概念设计
* 详细设计
* 编码与单元测试
* 软件集成
* 部署维护

**支持的过程元素**：

* 配置管理：适应不同环境
* 质量保证
* 文档编写
* 组间协调
* 进度检查

### 3. 过程活动

*没有标准的、统一的、适用所有类型系统的软件过程。*

有4个最基本的软件工程活动：

1. 软件规格说明
2. 软件设计和实现
3. 软件有效性验证
4. 软件进化（维护）

#### (1) 软件规格说明

理解和定义系统需要提供哪些服务，以及找出开发和运行中的约束。  
目标是生产一个达成一致的需求文档。

1. 可行性研究：经济、技术、法律
2. 需求导出和分析：与用户进行座谈、跟班、原型展示等，互相讨论分析需求，收集需求
3. 需求描述：在分析活动中收集的信息，以文档的形式确定
4. 需求有效性验证：检查需求的现实性、一致性、完备性，找文档的错

**形成**：需求规格说明书

#### (2) 软件设计和实现

把系统描述成一个可运行的系统的过程。

* 设计**输入**  
  需求规格、限制约束、……
* 设计**过程**  
  体系结构设计、接口设计和数据库设计，三者完成概要设计（系统架构）；组件设计即为详细设计。
  * 体系结构设计
  * 接口设计：程序需要安全可靠、复用性修改性强，则需要高内聚低耦合，接口则实现模块分离和低耦合
  * 数据库设计
  * 组件(Component)设计
* 设计**输出**
  * 系统体系结构设计
  * 数据库描述
  * 接口描述
  * 组件描述

即包含两大类：**概要设计**和**详细设计**

#### (3) 软件有效性验证

* 组件（单元）测试
* 系统（集成）测试
* 接受（确认）测试

#### (4) 软件进化

因为很少有完全重新开发的系统，而是边开发和边维护，  
因此软件开发和维护不再是两个独立的过程，而是一个进化的过程。

### 4. 过程描述

过程描述即要描述过程中活动及其顺序，以及每个活动中的产品交付物、角色和前后置条件。

1. **产品交付物**：软件过程活动的结果，如体系结构设计的产出物是体系结构模型
2. **角色**：反应人在软件过程中职责，如项目经理、配置经历、程序员等
3. **前后置条件**：一个过程活动在执行前或执行必须满足的条件，如体系结构设计之前需要客户已认可需求分析，

## 二、常用过程模型

不同阶段划分方式，各阶段要求的不同标准，形成不同的模型，即为“软件过程模型”（过程范式）。

最常见有3种：

* 瀑布模型  
  串行化，有明确划分、独立的过程阶段。
* 增量模型  
  需求不能完全明确（但明确最核心需求），在开发过程中增加需求，每个版本添加部分功能到之前版本。
* 基于构件的开发模型  
  （大型公司有很多写好的构件）依赖可复用的构件或系统，开发过程中关注在新的环境中，配置这些构件，集成为一个系统。

### 1. 瀑布模型

*是最早的模型。*

**流程**：

1. 需求分析与软件定义  
   通过咨询系统用户建立系统的**服务、约束和目标**。并对其详细定义，形成**系统描述**。  
   定义好需求之后，就需要**冻结**需求，不再变化。
2. 系统和软件设计  
   将**需求分配**到硬件或软件系统上，建立一个总体的**系统体系结构**，识别并描述基本**软件系统抽象**及其他们之间的**关系**。  
   模块的分布、内外部通讯、数据结构。
3. 实现和单元测试  
   将软件设计实现为一组程序或程序单元，单元测试就是检验每个单元是否符合其规格说明。  
   设计单元（模块）的过程中就需要进行单元测试
4. 集成和系统测试  
   集成单个的程序单元或一组程序，并对系统整体进行测试，以确保其满足了软件的需求。  
   在测试之后，软件系统将交付给客户使用。
5. 运行和维护  
   生命周期最长

**特点**：

* 计划驱动：开始工作之前，必须对所有过程活动制定计划
* 阶段分明：上一个阶段完成才启动下一阶段，每个阶段结果是一个或多个经过核准的文档
* 反复迭代：各个活动之间存在反馈和迭代
* 适度冻结：会需求冻结
* 重视文档：文档是阶段成果和交互的唯一凭据

**优点**：

* 在开发早期阶段需求就被完整确定
* 质量和维护可以得到保证

**缺点**：

* 现实客户很难明确描述软件需求，需求无法确定，导致之后的阶段也无法启动
* 步骤繁琐，不灵活
* 难以响应客户需求更改
* 早期的错误可能要测试阶段才能发现

**使用**：

* 嵌入式系统：硬件不灵活
* 安全需求高系统：需要对安全性和信息安全进行审核，需要文档必须完整
* 大型软件系统：涉及多家企业合作开发，完整的规格文档可以使不同子系统独立开发

### 2. 增量过程模型

对于互联网，迅速占领市场很重要，而瀑布模式太过繁琐，所以需要更快速的开发模型。

**过程**：

1. 定义框架需求  
   定义系统框架层面的需求
2. 设计体系结构  
   设计支持扩展的好的框架（地基要打好）
3. 增量开发  
   一个功能以一个增量的形式开发，核心功能有限开发。  
   **每个增量同样要经历**：分析、设计、编码、测试、完成
   1. 增量1
   2. 增量2
   3. 增量$n$
4. 最终软件系统

**特点**：

* 规格说明、开发、有效性验证活动不是分离的，而是交织在一起
* 并非提前制定出完整的问题解决方案，而是逐步逼近
* 系统的每一个增量或版本包括用户需求的一部分功能（按重要性排序）
* 适用开放的体系结构（如Web），不适用大型的系统

**优点**：

* 降低适应用户需求变更的成本
* 开发过程中更容易得到用户对于已做的开发工作的反馈意见
* 快捷的交付产品，更易占领市场

**缺点**：

* 过程不可见
* 随着增量的添加，系统结构退化

### 3. 面向复用的软件工程

软件实际开发状况：多数软件都是针对某个具体的应用系统从头开始开发，会导致出现大量的同类工作。  
利用工业上的知识，将组件装配起来得到产品。

面向复用的方法依赖于一个可复用的**软件构件库**，以及一个用于构件组装的**集成框架**。  
强调适用可复用的软件组件来设计计算机软件。

**流程**：

1. 需求规格说明  
   还是要先分析好需求。
2. 组件分析  
   根据需求描述，搜索能满足需求的组件，对候选组件评估。
3. 需求精化  
   利用发现的可复用组件的信息，对需求进行精化，对需求进行修改、进行配置后，再进行使用。
4. 面向复用的系统设计  
   在设计系统偶你的框架，或重复使用一个一存在的框架。
5. 开发和集成  
   集成所有已有的构件，开发没有的构件，在框架中进行集成。
6. 系统有效性验证

> 扩展 - 框架和组件：
>
> * 框架：是应用程序半成品，提供可重用公共结构，封装了某领域内处理流程的**控制逻辑**。  
>   框架描述了应用系统中：所有的构件、构件之间的交互、连接件、如何将构件和连接件结合的规则。

要点：一般情况不要修改框架的核心代码。

> 扩展 - 技术、构件、框架和系统的区别：
>
> | 概念 | 说明             | 举例     |
> | ---- | ------------------ | ---------- |
> | 技术 | 解决一类问题的方法 | JSP、XML  |
> | 构建 |                    | 控制器构建 |
> | 框架 |                    | Vue        |
> | 系统 |                    |            |
>
> ---
>
> 扩展 - 各类框架：
>
> * 前端 - Vue框架
>   * 数据驱动视图
>   * MVVM模式
> * Spring Cloud  
>   是一系列框架的有序集合，利用Sprint Boot的开发便携性简化了分布式系统基础设施的开发。
> * MyBatis数据持久层框架  
>   封装了JDBC的很多细节，使开发者只需要关注SQL语句本身，而不需要关注创建连接等繁杂过程。
>
> 注意：用框架并不是完全的基于组件的开发方式。

**适用**：

* 标准服务开发的Web服务
* 对象的集合
* 独立的软件系统

**构件组装**：

建立各个构件的联系（逻辑联系：树形、图形；代码联系：接口调用）

* 构件并行组装：同时调用多个构件的接口
* 构件连接（串行）组装：依次调用多个构件的接口，但可能会跳过、回溯等，不严格
* 构件选择组装：根据条件，选择若干个构件中的一个调用
* 构件复制组装：根据应用状态，复制自己的实例（为虚拟机），提高性能、可靠性、独立性
* 构件顺序组装：类似于构件连接组装，但有严格的顺序
* 构件中断组装：平时都执行$A$，但$B$有中断信号则立刻中断$A$执行$B$（与选择不同，中断可以在执行某一分支过程中中断）

**优点**：

* 复用已有构件，不再从头开发，开发速度快
* 维护过程就是构件的升级、替换和扩充过程
* 长期使用和复用，构件稳定，安全性高，结构同一，以学习和维护
* 专注于业务逻辑实现

**缺点**：

* 系统进化的控制问题  
  采用别人的构件，只能等别人升级，或者自己开发。

---

没有标准的软件过程，  
不同场合选择不同的过程模型，不同的过程模型也可以融合（以一个为主，其他作为辅助）。

## 三、应对变更过程模型

对于所有大型项目，**变更**是无法避免的，存在动态演化性（不停止服务的情况下升级软件）。  
因此软件开发需要及时处理变更。

* 软件变更是必然事件
* 某些变更是可以避免的
* 某些变更是必须接受的

存在应对变更的过程模型，也成为演化过程模型。

### 1. 原型开发

对于文字的文档，向用户交流存在困难，  
因此可以开发一个原型系统，用原型来向用户展示并交流。

当需求很模糊的时候，能帮助开发人员和利益相关者了解系统要做什么、能不能做等问题。

**典型的原型有**：

* 界面原型：UI、基本的业务流程
* 算法原型：对算法的要求

**过程**：

1. 建立原型目标 - 原型构造计划  
   可能是界面原型，也可能是验证系统功能需求，也可能是向管理者证明可行性。
2. 定义原型功能 - 概要定义  
   决定部分重要功能放入原型系统。
3. 开发原型 - **可执行**的原型  
   开发的过程中要求不严格，可能放弃一些非功能需求。
4. 评估原型 - 评估报告  
   进行评估，并根据反馈调整之后的开发计划。

**作用**：

* 软件工程过程中，原型有助于启发和验证系统需求
* 可勇于探索特定软件的解决方案，支持用户接口设计
* 开发时可能发现已提出需求的错误和遗漏

**问题**：

* 不可能调整原型以调整非功能新的需求（如只注重准确性、忽视效率如并发等）
* 原型开发没有文档，不易于维护
* 原型开发过程的变更可能破坏系统结构
* 原型开发时质量标准被放弃了

### 2. 增量式交付

“增量式开发”不强调与用户的交互，而“增量式交付”在每个增量发布后强调部署在用户方，听取用户反馈。  
分第一期、第二期等，交付一些功能模块。

**优点**：

* 用户可以将早期的增量作为原型，从中获得对后面系统增量的需求经验
* 用户无需等到整个系统实现就能从中获利
* 变更能更容易嵌入系统
* 最重要的服务经过了最多的测试

**缺点**：

* 很难确定全部增量的公用设施
* 开发的是一个替换系统（新的系统）时，迭代开发也是很困难的
* 大客户（如政府部门）难以接受最后增量完成才能有完整系统描述的方式，而需要一开始就有完整系统描述（就是不要画饼跑路）

### 3.Boehm 螺旋模型

也是分阶段周期进行开发：

1. 目标设置
2. 风险评估和规避  
   如有需求不合适的风险，可能需要开发原型
3. 开发和有效性验证
4. 规划

主要区别就是含有项目**风险评估**。

---

![图 1](images/2.%20Software_Process--04-21_12-08-36.png)  
![图](images/2.%20Software_Process--2023-04-21_12-08-11.png)
# 第六节 计算机硬件对函数调用的支持

当调用函数的时候，需要从一个函数切换到另一个函数。  
还要考虑参数和返回值的传递、子函数里的局部变量等问题。

如下程序：

```c
int Add(int a1, int b1)
{
    int z=0;
    z = a1 + b1;
    return z;
}
int main()
{
    int a = 10;
    int b = 20;
    int ret;
    ret = Add(a, b);
    return 0;
}
```

## 一、栈帧

现代计算机在高语言程序调用函数时，使用**栈帧结构**。  
不同硬件和编译器，可能采用不同的函数调用框架和栈帧结构，但必须保证：

* 参数放在子函数可以访问的位置。
* 返回值放在主函数可以访问的位置。
* a

## 二、x86硬件对C语言函数调用的支持

### 1. 寄存器

* `EBP` - 基址寄存器，指向**栈帧底部**。
* `ESP` - 栈顶寄存器，指向**栈帧顶部**。
* `IP` - 指令指针（即**程序计数器**`PC`）
* `EAX` - 函数只有单个返回值时，**存放返回值**。

给子程序传递参数：通过**堆栈传递**。

### 2. 栈帧结构

每当执行一个函数（包括`main`主函数），都会在主存内申请一个栈帧结构。

* 局部变量 - 靠近主栈帧栈底  
  并不是紧邻的，可能有间隙（与对齐方式有关）
* 所传递的参数 - 靠近主栈帧栈顶  
  若寄存器足够，优先考虑存在寄存器中。
* 返回到主函数的地址 - 主栈帧栈顶
* 返回值 - 某个寄存器（如`EAX`）

每新申请一个栈帧，都会放在该栈帧的正上方，  
这样，子函数方便寻找参数（就在下方附近），  
也方便返回主函数（返回地址就在栈底下一个单元）。

> 拓展 - 故意插入随机无用的空间占用：
>
> 别人可能通过内存修改，在某个单元插入自己的恶意代码，  
> 如果不随即插入无用空间，别人就可以通过分析寻找规律，在程序执行过程中执行到该恶意代码单元。

要把主函数的栈底`EBP`，以及主函数所使用的寄存器，  
都放入子函数的栈内，保存下来。

> 扩展 - 单元初始化填充`...CCH`
>
> 仍然是安全性问题，黑客可能通过溢出等方法将恶意代码放入栈帧内部，然后等函数跳转到其之前的位置，  
> 若填充`...00H`，会形成“空雪橇”，不断下滑到恶意代码块，  
> 若填充`...CCH`，表示一个错误，会终止程序。

---

函数内的代码要避免“内存越界引用”和“缓冲区溢出”，  
否则可能造成严重的安全隐患。

如：C中的`gets()`函数，没有做安全检查，  
当使用该函数时，若缓冲区（就是要读入的字符串）空间过小，  
则发生缓冲区溢出，多余的数据覆盖其他本不属于该缓冲区的单元，造成程序出错甚至执行恶意代码。

又比如需要注意无符号数，当从0减1时，会变为很大的数，  
则可能造成内存越界引用。

## 三、其他CPU硬件对C语言函数调用的支持

### 1. x86-64架构（64位系统）

可以**通过寄存器**最多**传递6个整形参数**。  
**超过6个整数参数**时，超出的部分通过栈来传递。​

### 2. MIPS架构

CPU内部配备较多寄存器，  
在函数调用时甚至分配了32个寄存器。

遵守以下约定：

* $a0 - $a3: 用于传递参数的4个参数寄存器。​
* $V0 - $V1: 用于返回值的2个值寄存器。​
* $ra: 用于返回起始点的返回地址寄存器。​

若函数需要使用**多于4个参数寄存器**和**2个返回值寄存器**，则通过栈传递。​
x   
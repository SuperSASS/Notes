# 习题总结

## 数据

* 规格化浮点数：$\frac{1}{r}\le|M|<1$  
  原码 - `x.1xxx...`
* 补码：
  $$
  [X]_{\textrm {补 }}=\left\{\begin{array}{lr}
  X & 0 \leqslant X<2^{n} \\
  2^{n+1}+X=2^{n+1}-|X| & -2^{n} \leqslant X<0
  \end{array}\pmod{2^{n+1}}\right.
  $$
  纯小数负数：$[X]_\textrm{补}=2+X$  
  $n=0$代表纯小数。  
  可以用来转换补码与真值。

## 指令

* 计算扩展指令 - $n$地址指令最多有多少条：  
  先算出还剩下多少条，再除以$n$地址指令最低位权。
  如$8$位，地址$3$，二(2)一(5)零(8)，二用了$2$、零用了$10$，则剩：$(2^2-2)*2^3*2^3-10=118$，  
  则可编$118/8=14$。（高指令并不一定只是$111\cdots$才表示扩展，低指令也不一定只用所给的位数那么多条）。
* 一个机器指令包含多条微指令，一个微指令可以为多条机器指令服务。

## 运算

* 补码乘法  
  ![图 1](images/%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93--06-21_17-31-47.png)  
  关键：X进B(-X)，Y进C，0进A。C的最后两位，只运算不位移
* 补码除法  
  ![图 2](images/%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93--06-21_17-32-00.png)  
  关键：X进A，Y进B(-Y)，0进C。先根据XY进行一次加减，再循环判断“同号商0加、异号商1减”。  
  结果：$C+\frac{A\times2^{-n}}{|C|}$

## 存储

* 刷新周期、次数：看**单独的一个芯片**（即便是若干个芯片组合的），**行选**为多少位。
* 独立编址：I/O、内存地址可以相同，要专门设置I/O指令`IN`
* 寻址范围：  
  > 字长$n$位，存储容量$x(G/M/K)B$，按(字/半字/字节/...)编址。
  
  计算：存储容量先换成$bit$，如4GB，$4\times1024\times1024\times1024\times8$(bit)，  
  再看按什么编址，则除以多少。按字则是$/n$，字节则是$/8$，按位编址则是$/1$。  
  注意：MAR也根据寻址范围来确定。
  
## CPU

## I/O

* 端口 - 寄存器的个数
* DMA - 在I/O和**主存**之间直接建立一条数据通路。